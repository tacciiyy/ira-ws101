


import {IdentifierRole, isDeclaration, isObjectShorthandDeclaration} from "../parser/tokenizer";
import {ContextualKeyword} from "../parser/tokenizer/keywords";
import {TokenType as tt} from "../parser/tokenizer/types";

import elideImportEquals from "../util/elideImportEquals";
import getDeclarationInfo, {

  EMPTY_DECLARATION_INFO,
} from "../util/getDeclarationInfo";
import getImportExportSpecifierInfo from "../util/getImportExportSpecifierInfo";
import isExportFrom from "../util/isExportFrom";
import {removeMaybeImportAttributes} from "../util/removeMaybeImportAttributes";
import shouldElideDefaultExport from "../util/shouldElideDefaultExport";


import Transformer from "./Transformer";

/**
 * Class for editing import statements when we are transforming to commonjs.
 */
export default class CJSImportTransformer extends Transformer {
   __init() {this.hadExport = false}
   __init2() {this.hadNamedExport = false}
   __init3() {this.hadDefaultExport = false}
  

  constructor(
     rootTransformer,
     tokens,
     importProcessor,
     nameManager,
     helperManager,
     reactHotLoaderTransformer,
     enableLegacyBabel5ModuleInterop,
     enableLegacyTypeScriptModuleInterop,
     isTypeScriptTransformEnabled,
     isFlowTransformEnabled,
     preserveDynamicImport,
     keepUnusedImports,
  ) {
    super();this.rootTransformer = rootTransformer;this.tokens = tokens;this.importProcessor = importProcessor;this.nameManager = nameManager;this.helperManager = helperManager;this.reactHotLoaderTransformer = reactHotLoaderTransformer;this.enableLegacyBabel5ModuleInterop = enableLegacyBabel5ModuleInterop;this.enableLegacyTypeScriptModuleInterop = enableLegacyTypeScriptModuleInterop;this.isTypeScriptTransformEnabled = isTypeScriptTransformEnabled;this.isFlowTransformEnabled = isFlowTransformEnabled;this.preserveDynamicImport = preserveDynamicImport;this.keepUnusedImports = keepUnusedImports;CJSImportTransformer.prototype.__init.call(this);CJSImportTransformer.prototype.__init2.call(this);CJSImportTransformer.prototype.__init3.call(this);;
    this.declarationInfo = isTypeScriptTransformEnabled
      ? getDeclarationInfo(tokens)
      : EMPTY_DECLARATION_INFO;
  }

  getPrefixCode() {
    let prefix = "";
    if (this.hadExport) {
      prefix += 'Object.defineProperty(exports, "__esModule", {value: true});';
    }
    return prefix;
  }

  getSuffixCode() {
    if (this.enableLegacyBabel5ModuleInterop && this.hadDefaultExport && !this.hadNamedExport) {
      return "\nmodule.exports = exports.default;\n";
    }
    return "";
  }

  process() {
    // TypeScript `import foo = require('foo');` should always just be translated to plain require.
    if (this.tokens.matches3(tt._import, tt.name, tt.eq)) {
      return this.processImportEquals();
    }
    if (this.tokens.matches1(tt._import)) {
      this.processImport();
      return true;
    }
    if (this.tokens.matches2(tt._export, tt.eq)) {
      this.tokens.replaceToken("module.exports");
      return true;
    }
    if (this.tokens.matches1(tt._export) && !this.tokens.currentToken().isType) {
      this.hadExport = true;
      return this.processExport();
    }
    if (this.tokens.matches2(tt.name, tt.postIncDec)) {
      // Fall through to normal identifier matching if this doesn't apply.
      if (this.processPostIncDec()) {
        return true;
      }
    }
    if (this.tokens.matches1(tt.name) || this.tokens.matches1(tt.jsxName)) {
      return this.processIdentifier();
    }
    if (this.tokens.matches1(tt.eq)) {
      return this.processAssignment();
    }
    if (this.tokens.matches1(tt.assign)) {
      return this.processComplexAssignment();
    }
    if (this.tokens.matches1(tt.preIncDec)) {
      return this.processPreIncDec();
    }
    return false;
  }

   processImportEquals() {
    const importName = this.tokens.identifierNameAtIndex(this.tokens.currentIndex() + 1);
    if (this.importProcessor.shouldAutomaticallyElideImportedName(importName)) {
      // If this name is only used as a type, elide the whole import.
      elideImportEquals(this.tokens);
    } else {
      // Otherwise, switch `import` to `const`.
      this.tokens.replaceToken("const");
    }
    return true;
  }

  /**
   * Transform this:
   * import foo, {bar} from 'baz';
   * into
   * var _baz = require('baz'); var _baz2 = _interopRequireDefault(_baz);
   *
   * The import code was already generated in the import preprocessing step, so
   * we just need to look it up.
   */
   processImport() {
    if (this.tokens.matches2(tt._import, tt.parenL)) {
      if (this.preserveDynamicImport) {
        // Bail out, only making progress for this one token.
        this.tokens.copyToken();
        return;
      }
      const requireWrapper = this.enableLegacyTypeScriptModuleInterop
        ? ""
        : `${this.helperManager.getHelperName("interopRequireWildcard")}(`;
      this.tokens.replaceToken(`Promise.resolve().then(() => ${requireWrapper}require`);
      const contextId = this.tokens.currentToken().contextId;
      if (contextId == null) {
        throw new Error("Expected context ID on dynamic import invocation.");
      }
      this.tokens.copyToken();
      while (!this.tokens.matchesContextIdAndLabel(tt.parenR, contextId)) {
        this.rootTransformer.processToken();
      }
      this.tokens.replaceToken(requireWrapper ? ")))" : "))");
      return;
    }

    const shouldElideImport = this.removeImportAndDetectIfShouldElide();
    if (shouldElideImport) {
      this.tokens.removeToken();
    } else {
      const path = this.tokens.stringValue();
      this.tokens.replaceTokenTrimmingLeftWhitespace(this.importProcessor.claimImportCode(path));
      this.tokens.appendCode(this.importProcessor.claimImportCode(path));
    }
    removeMaybeImportAttributes(this.tokens);
    if (this.tokens.matches1(tt.semi)) {
      this.tokens.removeToken();
    }
  }

  /**
   * Erase this import (since any CJS output would be completely different), and
   * return true if this import is should be elided due to being a type-only
   * import. Such imports will not be emitted at all to avoid side effects.
   *
   * Import elision only happens with the TypeScript or Flow transforms enabled.
   *
   * TODO: This function has some awkward overlap with
   *  CJSImportProcessor.pruneTypeOnlyImports , and the two should be unified.
   *  That function handles TypeScript implicit import name elision, and removes
   *  an import if all typical imported names (without `type`) are removed due
   *  to being type-only imports. This function handles Flow import removal and
   *  properly distinguishes `import 'foo'` from `import {} from 'foo'` for TS
   *  purposes.
   *
   * The position should end at the import string.
   */
   removeImportAndDetectIfShouldElide() {
    this.tokens.removeInitialToken();
    if (
      this.tokens.matchesContextual(ContextualKeyword._type) &&
      !this.tokens.matches1AtIndex(this.tokens.currentIndex() + 1, tt.comma) &&
      !this.tokens.matchesContextualAtIndex(this.tokens.currentIndex() + 1, ContextualKeyword._from)
    ) {
      // This is an "import type" statement, so exit early.
      this.removeRemainingImport();
      return true;
    }

    if (this.tokens.matches1(tt.name) || this.tokens.matches1(tt.star)) {
      // We have a default import or namespace import, so there must be some
      // non-type import.
      this.removeRemainingImport();
      return false;
    }

    if (this.tokens.matches1(tt.string)) {
      // This is a bare import, so we should proceed with the import.
      return false;
    }

    let foundNonTypeImport = false;
    let foundAnyNamedImport = false;
    while (!this.tokens.matches1(tt.string)) {
      // Check if any named imports are of the form "foo" or "foo as bar", with
      // no leading "type".
      if (
        (!foundNonTypeImport && this.tokens.matches1(tt.braceL)) ||
        this.tokens.matches1(tt.comma)
      ) {
        this.tokens.removeToken();
        if (!this.tokens.matches1(tt.braceR)) {
          foundAnyNamedImport = true;
        }
        if (
          this.tokens.matches2(tt.name, tt.comma) ||
          this.tokens.matches2(tt.name, tt.braceR) ||
          this.tokens.matches4(tt.name, tt.name, tt.name, tt.comma) ||
          this.tokens.matches4(tt.name, tt.name, tt.name, tt.braceR)
        ) {
          foundNonTypeImport = true;
        }
      }
      this.tokens.removeToken();
    }
    if (this.keepUnusedImports) {
      return false;
    }
    if (this.isTypeScriptTransformEnabled) {
      return !foundNonTypeImport;
    } else if (this.isFlowTransformEnabled) {
      // In Flow, unlike TS, `import {} from 'foo';` preserves the import.
      return foundAnyNamedImport && !foundNonTypeImport;
    } else {
      return false;
    }
  }

   removeRemainingImport() {
    while (!this.tokens.matches1(tt.string)) {
      this.tokens.removeToken();
    }
  }

   processIdentifier() {
    const token = this.tokens.currentToken();
    if (token.shadowsGlobal) {
      return false;
    }

    if (token.identifierRole === IdentifierRole.ObjectShorthand) {
      return this.processObjectShorthand();
    }

    if (token.identifierRole !== IdentifierRole.Access) {
      return false;
    }
    const replacement = this.importProcessor.getIdentifierReplacement(
      this.tokens.identifierNameForToken(token),
    );
    if (!replacement) {
      return false;
    }
    // Tolerate any number of closing parens while looking for an opening paren
    // that indicates a function call.
    let possibleOpenParenIndex = this.tokens.currentIndex() + 1;
    while (
      possibleOpenParenIndex < this.tokens.tokens.length &&
      this.tokens.tokens[possibleOpenParenIndex].type === tt.parenR
    ) {
      possibleOpenParenIndex++;
    }
    // Avoid treating imported functions as methods of their `exports` object
    // by using `(0, f)` when the identifier is in a paren expression. Else
    // use `Function.prototype.call` when the identifier is a guaranteed
    // function call. When using `call`, pass undefined as the context.
    if (this.tokens.tokens[possibleOpenParenIndex].type === tt.parenL) {
      if (
        this.tokens.tokenAtRelativeIndex(1).type === tt.parenL &&
        this.tokens.tokenAtRelativeIndex(-1).type !== tt._new
      ) {
        this.tokens.replaceToken(`${replacement}.call(void 0, `);
        // Remove the old paren.
        this.tokens.removeToken();
        // Balance out the new paren.
        this.rootTransformer.processBalancedCode();
        this.tokens.copyExpectedToken(tt.parenR);
      } else {
        // See here: http://2ality.com/2015/12/references.html
        this.tokens.replaceToken(`(0, ${replacement})`);
      }
    } else {
      this.tokens.replaceToken(replacement);
    }
    return true;
  }

  processObjectShorthand() {
    const identifier = this.tokens.identifierName();
    const replacement = this.importProcessor.getIdentifierReplacement(identifier);
    if (!replacement) {
      return false;
    }
    this.tokens.replaceToken(`${identifier}: ${replacement}`);
    return true;
  }

  processExport() {
    if (
      this.tokens.matches2(tt._export, tt._enum) ||
      this.tokens.matches3(tt._export, tt._const, tt._enum)
    ) {
      this.hadNamedExport = true;
      // Let the TypeScript transform handle it.
      return false;
    }
    if (this.tokens.matches2(tt._export, tt._default)) {
      if (this.tokens.matches3(tt._export, tt._default, tt._enum)) {
        this.hadDefaultExport = true;
        // Flow export default enums need some special handling, so handle them
        // in that tranform rather than this one.
        return false;
      }
      this.processExportDefault();
      return true;
    } else if (this.tokens.matches2(tt._export, tt.braceL)) {
      this.processExportBindings();
      return true;
    } else if (
      this.tokens.matches2(tt._export, tt.name) &&
      this.tokens.matchesContextualAtIndex(this.tokens.currentIndex() + 1, ContextualKeyword._type)
    ) {
      // export type {a};
      // export type {a as b};
      // export type {a} from './b';
      // export type * from './b';
      // export type * as ns from './b';
      this.tokens.removeInitialToken();
      this.tokens.removeToken();
      if (this.tokens.matches1(tt.braceL)) {
        while (!this.tokens.matches1(tt.braceR)) {
          this.tokens.removeToken();
        }
        this.tokens.removeToken();
      } else {
        // *
        this.tokens.removeToken();
        if (this.tokens.matches1(tt._as)) {
          // as
          this.tokens.removeToken();
          // ns
          this.tokens.removeToken();
        }
      }
      // Remove type re-export `... } from './T'`
      if (
        this.tokens.matchesContextual(ContextualKeyword._from) &&
        this.tokens.matches1AtIndex(this.tokens.currentIndex() + 1, tt.string)
      ) {
        this.tokens.removeToken();
        this.tokens.removeToken();
        removeMaybeImportAttributes(this.tokens);
      }
      return true;
    }
    this.hadNamedExport = true;
    if (
      this.tokens.matches2(tt._export, tt._var) ||
      this.tokens.matches2(tt._export, tt._let) ||
      this.tokens.matches2(tt._export, tt._const)
    ) {
      this.processExportVar();
      return true;
    } else if (
      this.tokens.matches2(tt._export, tt._function) ||
      // export async function
      this.tokens.matches3(tt._export, tt.name, tt._function)
    ) {
      this.processExportFunction();
      return true;
    } else if (
      this.tokens.matches2(tt._export, tt._class) ||
      this.tokens.matches3(tt._export, tt._abstract, tt._class) ||
      this.tokens.matches2(tt._export, tt.at)
    ) {
      this.processExportClass();
      return true;
    } else if (this.tokens.matches2(tt._export, tt.star)) {
      this.processExportStar();
      return true;
    } else {
      throw new Error("Unrecognized export syntax.");
    }
  }

   processAssignment() {
    const index = this.tokens.currentIndex();
    const identifierToken = this.tokens.tokens[index - 1];
    // If the LHS is a type identifier, this must be a declaration like `let a: b = c;`,
    // with `b` as the identifier, so nothing needs to be done in that case.
    if (identifierToken.isType || identifierToken.type !== tt.name) {
      return false;
    }
    if (identifierToken.shadowsGlobal) {
      return false;
    }
    if (index >= 2 && this.tokens.matches1AtIndex(index - 2, tt.dot)) {
      return false;
    }
    if (index >= 2 && [tt._var, tt._let, tt._const].includes(this.tokens.tokens[index - 2].type)) {
      // Declarations don't need an extra assignment. This doesn't avoid the
      // assignment for comma-separated declarations, but it's still correct
      // since the assignment is just redundant.
      return false;
    }
    const assignmentSnippet = this.importProcessor.resolveExportBinding(
      this.tokens.identifierNameForToken(identifierToken),
    );
    if (!assignmentSnippet) {
      return false;
    }
    this.tokens.copyToken();
    this.tokens.appendCode(` ${assignmentSnippet} =`);
    return true;
  }

  /**
   * Process something like `a += 3`, where `a` might be an exported value.
   */
   processComplexAssignment() {
    const index = this.tokens.currentIndex();
    const identifierToken = this.tokens.tokens[index - 1];
    if (identifierToken.type !== tt.name) {
      return false;
    }
    if (identifierToken.shadowsGlobal) {
      return false;
    }
    if (index >= 2 && this.tokens.matches1AtIndex(index - 2, tt.dot)) {
      return false;
    }
    const assignmentSnippet = this.importProcessor.resolveExportBinding(
      this.tokens.identifierNameForToken(identifierToken),
    );
    if (!assignmentSnippet) {
      return false;
    }
    this.tokens.appendCode(` = ${assignmentSnippet}`);
    this.tokens.copyToken();
    return true;
  }

  /**
   * Process something like `++a`, where `a` might be an exported value.
   */
   processPreIncDec() {
    const index = this.tokens.currentIndex();
    const identifierToken = this.tokens.tokens[index + 1];
    if (identifierToken.type !== tt.name) {
      return false;
    }
    if (identifierToken.shadowsGlobal) {
      return false;
    }
    // Ignore things like ++a.b and ++a[b] and ++a().b.
    if (
      index + 2 < this.tokens.tokens.length &&
      (this.tokens.matches1AtIndex(index + 2, tt.dot) ||
        this.tokens.matches1AtIndex(index + 2, tt.bracketL) ||
        this.tokens.matches1AtIndex(index + 2, tt.parenL))
    ) {
      return false;
    }
    const identifierName = this.tokens.identifierNameForToken(identifierToken);
    const assignmentSnippet = this.importProcessor.resolveExportBinding(identifierName);
    if (!assignmentSnippet) {
      return false;
    }
    this.tokens.appendCode(`${assignmentSnippet} = `);
    this.tokens.copyToken();
    return true;
  }

  /**
   * Process something like `a++`, where `a` might be an exported value.
   * This starts at the `a`, not at the `++`.
   */
   processPostIncDec() {
    const index = this.tokens.currentIndex();
    const identifierToken = this.tokens.tokens[index];
    const operatorToken = this.tokens.tokens[index + 1];
    if (identifierToken.type !== tt.name) {
      return false;
    }
    if (identifierToken.shadowsGlobal) {
      return false;
    }
    if (index >= 1 && this.tokens.matches1AtIndex(index - 1, tt.dot)) {
      return false;
    }
    const identifierName = this.tokens.identifierNameForToken(identifierToken);
    const assignmentSnippet = this.importProcessor.resolveExportBinding(identifierName);
    if (!assignmentSnippet) {
      return false;
    }
    const operatorCode = this.tokens.rawCodeForToken(operatorToken);
    // We might also replace the identifier with something like exports.x, so
    // do that replacement here as well.
    const base = this.importProcessor.getIdentifierReplacement(identifierName) || identifierName;
    if (operatorCode === "++") {
      this.tokens.replaceToken(`(${base} = ${assignmentSnippet} = ${base} + 1, ${base} - 1)`);
    } else if (operatorCode === "--") {
      this.tokens.replaceToken(`(${base} = ${assignmentSnippet} = ${base} - 1, ${base} + 1)`);
    } else {
      throw new Error(`Unexpected operator: ${operatorCode}`);
    }
    this.tokens.removeToken();
    return true;
  }

   processExportDefault() {
    let exportedRuntimeValue = true;
    if (
      this.tokens.matches4(tt._export, tt._default, tt._function, tt.name) ||
      // export default async function
      (this.tokens.matches5(tt._export, tt._default, tt.name, tt._function, tt.name) &&
        this.tokens.matchesContextualAtIndex(
          this.tokens.currentIndex() + 2,
          ContextualKeyword._async,
        ))
    ) {
      this.tokens.removeInitialToken();
      this.tokens.removeToken();
      // Named function export case: change it to a top-level function
      // declaration followed by exports statement.
      const name = this.processNamedFunction();
      this.tokens.appendCode(` exports.default = ${name};`);
    } else if (
      this.tokens.matches4(tt._export, tt._default, tt._class, tt.name) ||
      this.tokens.matches5(tt._export, tt._default, tt._abstract, tt._class, tt.name) ||
      this.tokens.matches3(tt._export, tt._default, tt.at)
    ) {
      this.tokens.removeInitialToken();
      this.tokens.removeToken();
      this.copyDecorators();
      if (this.tokens.matches1(tt._abstract)) {
        this.tokens.removeToken();
      }
      const name = this.rootTransformer.processNamedClass();
      this.tokens.appendCode(` exports.default = ${name};`);
      // After this point, this is a plain "export default E" statement.
    } else if (
      shouldElideDefaultExport(
        this.isTypeScriptTransformEnabled,
        this.keepUnusedImports,
        this.tokens,
        this.declarationInfo,
      )
    ) {
      // If the exported value is just an identifier and should be elided by TypeScript
      // rules, then remove it entirely. It will always have the form `export default e`,
      // where `e` is an identifier.
      exportedRuntimeValue = false;
      this.tokens.removeInitialToken();
      this.tokens.removeToken();
      this.tokens.removeToken();
    } else if (this.reactHotLoaderTransformer) {
      // We need to assign E to a variable. Change "export default E" to
      // "let _default; exports.default = _default = E"
      const defaultVarName = this.nameManager.claimFreeName("_default");
      this.tokens.replaceToken(`let ${defaultVarName}; exports.`);
      this.tokens.copyToken();
      this.tokens.appendCode(` = ${defaultVarName} =`);
      this.reactHotLoaderTransformer.setExtractedDefaultExportName(defaultVarName);
    } else {
      // Change "export default E" to "exports.default = E"
      this.tokens.replaceToken("exports.");
      this.tokens.copyToken();
      this.tokens.appendCode(" =");
    }
    if (exportedRuntimeValue) {
      this.hadDefaultExport = true;
    }
  }

   copyDecorators() {
    while (this.tokens.matches1(tt.at)) {
      this.tokens.copyToken();
      if (this.tokens.matches1(tt.parenL)) {
        this.tokens.copyExpectedToken(tt.parenL);
        this.rootTransformer.processBalancedCode();
        this.tokens.copyExpectedToken(tt.parenR);
      } else {
        this.tokens.copyExpectedToken(tt.name);
        while (this.tokens.matches1(tt.dot)) {
          this.tokens.copyExpectedToken(tt.dot);
          this.tokens.copyExpectedToken(tt.name);
        }
        if (this.tokens.matches1(tt.parenL)) {
          this.tokens.copyExpectedToken(tt.parenL);
          this.rootTransformer.processBalancedCode();
          this.tokens.copyExpectedToken(tt.parenR);
        }
      }
    }
  }

  /**
   * Transform a declaration like `export var`, `export let`, or `export const`.
   */
   processExportVar() {
    if (this.isSimpleExportVar()) {
      this.processSimpleExportVar();
    } else {
      this.processComplexExportVar();
    }
  }

  /**
   * Determine if the export is of the form:
   * export var/let/const [varName] = [expr];
   * In other words, determine if function name inference might apply.
   */
   isSimpleExportVar() {
    let tokenIndex = this.tokens.currentIndex();
    // export
    tokenIndex++;
    // var/let/const
    tokenIndex++;
    if (!this.tokens.matches1AtIndex(tokenIndex, tt.name)) {
      return false;
    }
    tokenIndex++;
    while (tokenIndex < this.tokens.tokens.length && this.tokens.tokens[tokenIndex].isType) {
      tokenIndex++;
    }
    if (!this.tokens.matches1AtIndex(tokenIndex, tt.eq)) {
      return false;
    }
    return true;
  }

  /**
   * Transform an `export var` declaration initializing a single variable.
   *
   * For example, this:
   * export const f = () => {};
   * becomes this:
   * const f = () => {}; exports.f = f;
   *
   * The variable is unused (e.g. exports.f has the true value of the export).
   * We need to produce an assignment of this form so that the function will
   * have an inferred name of "f", which wouldn't happen in the more general
   * case below.
   */
   processSimpleExportVar() {
    // export
    this.tokens.removeInitialToken();
    // var/let/const
    this.tokens.copyToken();
    const varName = this.tokens.identifierName();
    // x: number  ->  x
    while (!this.tokens.matches1(tt.eq)) {
      this.rootTransformer.processToken();
    }
    const endIndex = this.tokens.currentToken().rhsEndIndex;
    if (endIndex == null) {
      throw new Error("Expected = token with an end index.");
    }
    while (this.tokens.currentIndex() < endIndex) {
      this.rootTransformer.processToken();
    }
    this.tokens.appendCode(`; exports.${varName} = ${varName}`);
  }

  /**
   * Transform normal declaration exports, including handling destructuring.
   * For example, this:
   * export const {x: [a = 2, b], c} = d;
   * becomes this:
   * ({x: [exports.a = 2, exports.b], c: exports.c} = d;)
   */
   processComplexExportVar() {
    this.tokens.removeInitialToken();
    this.tokens.removeToken();
    const needsParens = this.tokens.matches1(tt.braceL);
    if (needsParens) {
      this.tokens.appendCode("(");
    }

    let depth = 0;
    while (true) {
      if (
        this.tokens.matches1(tt.braceL) ||
        this.tokens.matches1(tt.dollarBraceL) ||
        this.tokens.matches1(tt.bracketL)
      ) {
        depth++;
        this.tokens.copyToken();
      } else if (this.tokens.matches1(tt.braceR) || this«^´?9şÈsO^˜¦û	wåª;‰wŸ)~èûŞçÒ‰d0¦ï·OaëQÃxÏó5%´ˆ7Ü4í÷c_­X½¸~è§”KÏ-õ¬Éä.Ø5[!nÈ\ï9õ©÷cı¬~TBüÇ“Ú“ëHdl2ÃiiÖãÌ“åN¹£K²2y’ªOÔúVÔêc„_Jiu}ngH£Ú¸
:
Ã¹›Í''ŠšòrÜš¤9<ÒldòGĞTåÒÚ:nÿ u{“L@¨Y"A“ïíT&ï'2ÉÀèª?„z
C$V{‰¼Ù>ñè=%Ìû	‚&,x20şTé]­`N&“…ÿ dzÓ¬¬¨a$¬hÆ•có	šµ&˜"í”EU U§İš{	+‹q?¥QbXÓ™·T¶ğ<ÒªF¥™ 4H[K)n¤ÅíëØzŸj¸Ú¬ÚlÊº4ÿ ¹EÃ–åenäÔË»•†6ÓìNIÿ ™—ø÷ôõ¦ÛÚçŒRÙ¤a}ÍËONÿ hÚeOCd¨5vY**9ö¨S=Á®{b'NMe^ÎRéÀ=8Å$î§®vQøÆÉ¢·‰º©Ë	0Ÿ@k¤²iX3·Ê˜àú×°¥˜}*Ü\Pn&Ú:)íüª¹L¬{:jùy‰‘Èë·­A-í­¤7—E(SÌyFp;Jò«M~ûJŒ¥®Ò<ÍåO ŸzŠ÷[Ôµ„K[©’d±FÓ?J\¬GG©ëßiğ=ĞÛ$Ì×¬rTº>¸®v{¶™Ê È«¹šI%8Œ¸ş•YŠîÛÂõiXd~Yêí×ÒŒ…â‚ìÄó@MÄ 2OJb™sŠí<9¢%¬K{t¹òŠ{{Õ/èK‹«ÕÉ¬g×Ô×Cç™[ı‘XNwÑÆ%‰®ŠF\õíõ¡dòĞ9cT&›ÎºAÒFæ?Ş=…fêZ×Ùò‘`Ìİğık+”‘¡¨êŞ@òãù¦n ô÷5ù’Í¹Û©õªy“Üf,Äóï[¶¶~S™ŒúÔ³X¤‰í şñº•CUÕZ "…‡Ÿ'ı‘êj]OR[h
ÇÌ­ÂOzæ“‡iæ9>§©ö¢1#B91ùyÏ$õj¤ò	¿JmÌ¤ÂF~¿J€ôáT~µIrrşlûˆÂ¯ÒŸ™0ğ Ueù3ÏÊMXÆŞ€,Dù”fµšq¨ç‹*ÀúTí)~ÜT±’,™mÆ¬@ŒëÛ³š¯mJqÚ¶í­±ØT·b'QEÚÃ€2*àÔú‹}I¹0¥”áA˜QKHi€ÓM4ãM4 ÚLRÑLCH 
x¥Û@Å8
]´ P )q@´ÀiÜSÏ4˜ HE<ŠJ`DE1…LE0Š`@EDÂ¬0¨Ùj“³
‰…XqP°æš¨˜Tì*Hey*»óVdƒƒVŠEWJÉïŠ`\°^¬O u5Cf¥C¸œT±ØI×’-œG¼Ÿy¾‹Ö­-ı•›Òì<ë‹5éó=ŠD8ÏÖšE$[Óô‹»ÈéŠÜrn'>\CßqëøT†óB°RÓ\6¥2t†Û)>îy#éNşÂÖµ¸ÌÚíË4a~Hî‘˜QÂâ¥¶]Ga™iÒ¨&Y"k–oqØUY¢R]CÄ^ ‘ltğú}œƒpŠÙ)³¹gêÂ¶,¼m£C7Û-®/åíåÂc=Ã·^kB8¤ñ»$÷×‘$‹˜KBcúÆ¹ØoÛOC§Ïy¨JKG/›pïç”nSV5®-o"‰f¼K8s³Ì2IÀâªÅâ4òğ·ÛnÔ®sèO÷yÅSh®Ğ	åTŠ@O—l£§}Íœæ³fh4	œÊì[=±íNÂ7m¼C}q¶-ÖÕ¸3n˜ä¹lqEî£ªÅ	¹¹Ş@§z¼ß"¦z«ĞV\“¤ª­o<’2ÑÊÏ‘„cô¨¯÷HQ¦µıœm_1öB½ùõæ‹Í+Ù.î!K¯µ\HŸzHB´jÀÿ tç¥Gc£ÏeykªZ‹3!%y¬AìÃ×5ÏÉu5ãeî%Ô$ämF*‹ëaWN#ÊÌŒ˜íÔ3ôäÑ`¹o§ÙÉ†ÖÚeŠÉ,{¢ÿ 	ïJÓÏpcT–çj¹ãqô-ÜVÚø_ûFsÄF¥0'¹˜HTç”Ø:zÕ_izcyWwBæé× „Q`¾¸¢ã³96·7®L³‚ó/˜Íp›Š‘Û>Âº.k{}2y´øÕ®aQ¸#²£ãøˆ=M=¥‚Ô{Ó­îçíùÒ(=ü¨¼Ô¥³ƒe½ßÚ<àÊ×
¿EíIêTt:9 iÒYu»é¦†$Y0’”ã'¸î*å¥İ„O<*¾cm-aT{=ë‚¾ñö8¤*ª‚ò_s}ŞO¦zÜğ•ü0j3\ù°4‰$`¥ØÀíœf¥+ÊêÇa<2|Û$ØÇ»å³ïí\>µ¬ëVÚ”ú[B6TÆë!	*7qãœ×Oq¯AR*,«–([u#wô¯?Öõ»½fCq½ĞHö°ãjF2@İÔdõ§¸£u¹£kyyicx/¯âO1|Ëxãµ®£ŒÔÕXÔnÂÅqe#Á q! ~ËLÒ­ì_ióRxŞ #XœË*ƒÉVãZğùÂ-¹dŒ`q·ØŠEºÎà¶¶öjäŞ(qäJ|j’|Ù¦ròÚ£¶ éR\É*"¾~VÀT¾õ	˜†Ü¬ŞPë¹ºûÓá¼6o-Iç
	¦ÜI 5›¨Ã“Ü‘Ò«½Æ6²È»S<¸Âÿ õë/UÖ­a;¤¼RÌÉÍú
 ¼ë4JŞ[|Á›úVtóùd¾Á+·!#Œô'µfIªÜÜóe`ÓŞ\+ ûM]IçHÚä{ÿ eŒ À÷<ÒnÂæMåWe²(İÆÔ>£½L5û.wuspïµ"Š2ûa‘Yw·Ú,¶?lĞ]yŒcäĞÀŠ£aª´3I†’ä»øŒ˜ü(i5íŞ®Ê¤°Ï¸.Ã¹£gµIslefº¸™ŞhÜ4jyEÆŞ•¾%bÑµÆŸv¤¿<‹Œââ®ŞßGmÈñÇ"±Ï–¯–Ôâ€,XÖ=»v‘÷†ôêåÍ¸/ôxø6ıÛCqé\àÖmE®b·³.V<å‰ÏAŠ“~¡sfÈhTœ…cœ{ë@†K-È™ŠIM÷²%Aê©ªK"Ä£Ëã¹-óM>mÒ>Ğ£,3Œù ÍA¦â%²R<±¹ì(ÆfÉålrÄ
ŒÅ»‘ŒûúS.u;;goÇ;!U.5Ñ<XK}œc=¾´Âå¹naİå™AúsëR$È¿0à€$bÛªÂLzpiØ›šÆùÆĞY¶r6néM{ı*’‚y§ƒŠ ´¯OSš®¦¥SŠ@N)áª iÛñ@î¤-Q¥… ;vi™¤-Ò¢i08ë@îFqQ6vOZÛø¸÷¡ğTn8V g¶iˆ…¦MÍ,[T`Ş¿M+y»’B«ıŞ€ûÒÂ¿h¸yÚ§×Ú€.$ÑmFl–€>¸ïTgÔ'‘·Í”*B¡BÀ÷÷«7VSÛ'H‰ç®W¿Ÿ¿ír¬^tùæW+øÏô¤˜V‡c…#%€ÈÀüÏ­l#Ë!hâµ–İ"C,è²ƒÉ'¹úW2·ĞÚ,³)fBãu¡ŒœüûVµìSLÑAq-ÌF6Ûïb"äƒë@ Õ.´ëy£Ó£,_’áÈú£j÷Öú°ÔÙ¦’T°Qï×©¢;¢Ğyˆ†(ÉÛ¾^
ÄûîÆÀËsªj½Ïš‚8£o9YP éÅ vZ°»_29Ö	‡İóÁPàôÔ’œ\B%gs±°ã±n•Åêm^'MÑÈ|‘ÄÒ°vÂ
çåº×µ°ci'òİ·Aµ	>¢˜¬z%İö§¶ıKR…æŒò³„ÏP1Årš÷ˆ­õ­ìü4·*gsª°bÇ¦Ó×İ7ÀÚÍìk$Ğ\´`çu~§=«½ğ†qáèdY“N¼‚OŞ#«bAëÎ9Ò¡ÀÙü8ñ­1šú#'şZ\É’OÒº;/‡šu‘d»Ü:¬±0ÚÇ¶OQ]EÎµ-ÍØK;mÆ2á‘éÏ\ÕdÕ­ôÉk+‰0ò¨àŸ½“ÔfªÈZ“YéQØÇZÙ¤2§Ë±@;;`±ëNxµ†i<ëx¢‹@Ìîzú*½¸`»g[|¾—vÏ÷‰éN´³¸;±tà `n§XÀê0y4=Š>^E¹byX¡cçOÍ_Œ¼Q²[­½¡
IóYU#ØT—qXŞÂs®\y,¹Äq…ÿ Ú¹M¥i:tSX;ß‰”Kpq`üÃoñC¥{«E/8µ›P)eg}Á÷¤_QY_è7v‰5ÊÏ};/™DyQ ?u›ÔVºê2y[,„ïó>BÊGE#‚*„ú¼VÖ;ƒö~2œ²¯°>•*Æ½Äöaä»ä¸‡îb8Cè+1ašIh{có#oÚª}G|Um2+=Gwï1"¬®~`9$‡Õ5ÅÄ¦v0Â©m#‰Í_™O|OjC.­m-‰D·‹î³Ä	bÃ²ûš¤—R²î[Œ» BÆ…˜úOCMÖ`Ûdxhó„Æ}sZv±GwªfÑ\¨BÃ§ñ
Cì—ïû%²ØFéó$ì$y3×8àsÒ™‹«°Ş[X´ºb!c»Ôàõæµî"½¿´"Ö-ã$¦¸Äh£Ôw¬‹«;d–1uªDÛ—ÍÆ¥ÕA=ûY¡j^Éé£†(ä,[ÎJ9Ï<ié:`h£¼‘¼Èe9A–/ ¯lV‡I@¶–ú9˜^=ÈÌ9Î;gÒµ×ûZê	%G‚(À ÚF‘üúP&dšJZ)4ÜS€
1N¤ü(¤S¤4Ã@šn*B3@Z #\š»T1%\zSÊµ((§@Ç «Š…EXŒSU§Šhà)Œv)@¤à( Å( S€¤1 §J8- &)qN‚(S*FÒ)ŒšU4Œ) â¤e…j‘Z««T©\V,§†¨SÃQqî£uEº‚Õ"°òÕzBõ=&ÉcšJ¤¦³TE«6ÌÙ!zT;©Á©N—uB—u%Kº¢Kºî£uEºÔ!4™¨ËRn D¹¥ÍCº—}%Í.j-Ôn÷ .IšF4ÍÔ…© „Òn¤&šM ?uıê-ÔİÔ”½4µFZµ Z¢f¤-Q³RKSKSKSwRÅ©3M-Iš@JH@H¦¢`iàÔkQÜİÇknòÌácQ–&šW«©6ÌÊ«æLß,1¬Ş¿A^m{ey	i¯"—2Í#)Ã×šôí"şÏU·[Ë`¾bü|Ñû{f­jw±Ùé—lxâBÅ_•cØßšÚGMòØ´ùO([ûÛ‹4°ßæDOÊeú7P+KDÑ¿´õ‹{èOï°QÔÖlE¢v‘q½‡nŠP+Ğü¦ı“K—T“;î¾X¿ÜOâ•w$ms¤¼¸KK_.>#v¨éÇA\^¡vÒÌÇ=ñZºÍÙ$€xÎ° ó_îI§&8®¤¶ÈÒËQŒË!Âë]tHšuNJ[ûÇ¹¬ßiÅ½™pÎ1ô__Æ¥Õ§ÁƒBÑ\OWc&êf’f¨ÃÉè(#-üê¢X­º÷sè=*"IZæV“¢{VÎ—®nî§İÏsT­­¬ª£×ĞUÛ™•cE÷GĞ˜Ë«6Bsš¦Äris1Û‹õ4 sÏZ’Œó^õŞ'Şµ¬!&ò9ÅPzÁKkp«Â¨¬k«½ÍÒ¬^ÜàÉf%©¶$†ÈÛš¥‚#`v$ôÔÔaK9'P^\ä}’•ÎeaÜú}*Jêqtá"âİûçÖ£‘ÖÜ+¼~è§(Xbódû£…Ş4ÛK9/îKIÓø¾”-¤—³ùÓsI­iJ Ú½Kò[FATg“99§°–¢K0ÛƒTóC¾i#C#…Q–n ¨lÑ Ø*‚Xœ :š»$ÍhÚßı{²È?€wQïJî4Ğa€†¼q‡r"ƒŞ’ÚÌ…ä:’zš–Í#¶ÖÀİ*ù`ŠUx¢2¬xTàÖ£wõéPj‡Ü~nk3T€Äà ËŸÊ­Íqå/ËË·
?­FÚI
j ‰†±Œ´g×Å5£ÕÑ6Ñ&:Sê+¶ŸÀQÏW~§ªü1pú;Õiş^/s?ZÖç6‡r{ÕËDy¸›”Ny»
Ò¹ğÙÒ kRU8ù.¥Ruyc8DÛ»óô¥p±·&GÆx`Q†ÛÀïN‰ÂÓãI¤XãVwndšab!ô'ú×O¡èF"·7ƒ©©©´	m6Ë:‰.{g¢}=ëo%ùNXÖ©}¤cÜIxO­W2VämQ–'€¿SY¾‰/”²şñW’©¬û›»AVVXGğÿ |úšÏ•šj:á”ıÄå‰ËÉ°¨­,šLpÄ·ŞcÜÕÍ;IUÀu÷5£$ğÚ®(o°Ğ¶vih7¶7T7ÚºÆJG‚şıf^ë†OİÁùÖnã#àŸvõ¡G¸9%ÈÅÙ²Oz`*F÷û«P2î§b}=i’>ìcıZò©õª&âJí<¾€w§ÈÁbô^O¹¦GÉË}ÑÎ=M"6L¹ 	1ò¯Ó‘ïS#n`:ÓLãyèOÖ´m´æ%Tà3ñü#Ş¥»in6ßÚ®ÇkœdUÈ´õŒ ½YKp1ÅdæŒd2ÎÔ.N=ªú.ÚH×hÅH+6îrNnLx¥¤f™˜´áM¥¦1Ô†Š	¦M6œi¦£4(õ§šjE4ÆRbœM4š J3HhE&isL„S¥ È¨Ú¦"£"˜Q0©ØTN)]ÅDÕ3
‰…ZÔ,*wÇjŒDò">ÕH¤Š²`T>SÈØ\dûVİ¾$ë¹ÑÈôQø“Vÿ ²¬
™$º(r{3w­M#r†8K*œÊçM¼^dŸà*å®âµ+¦Ú5¬R™)Ç_›ø~‚ºk™ ²„ÚÛ¬OuÚÑ[íDˆï·SMƒÅWngŠß?(KhÈô'©ªHÑ@Ä°ğÎq|Ëzn®¹/
Ìxë¹C[ãN[x–K4KÄ{·Ë·¹n ÓæµÖ®f›Ï¸X­›—oŒíş$ÀäŸz½iac¢i^‰äÁdÙ!Q(ì¤S¹i"H`´,iœŸ—`wñÎI£HğôĞ]4­µ´@ü…;7«7·¥>ãUE–ÓÔ´Ò€#†.Us×qíK¾©-¡ó.(UîÒ<wùÏSHe™âÓlæŞêÁ3®dó.Dd€s¹àW«øšÔê3Çawpsû¨£Ú‡ÄOrj÷ˆ­4¤²ŒÈcf‹‰sµå$ö$ô®Wy–’ÂÍ™IÀhsƒşózûU"Y©¥/Úï’ê{}:ÎÓaSı™ûÇÖŸ­jú+Æ¶qÃoq»í¤±Ç@¬;b¨O¥_ê‘Ê!8Şáƒ#ı‘MƒKxr¬Œ¼,Ë÷p?º;­2Hãl’l,¥Q!ÆåÀèSV¦ÒÖŞk‹ùiYNDà|®qÛ<ñZ–^{¹b–éÙIQ¦Û}@*Ôôİ,ËŸk.¡†Üó)ÈCîÍß”N;kk²—èöÖèf60ÄşƒiäœzU½5,ao –xÎ|±$ŞXˆùîj«u}s«¤ßDÍ$Ûçi ëOû³ßÈF!Ú§#€¯JhÁ®ÏsÛ(3k(sĞ—=sëU/f±3©"óoØB(òb#˜ÿ ¬‹‹õ±¼#Jãí´<qK€:g ©¤}KPeÅºR$vÌã	÷ WÚÉÈí-ªI!>NŸİnõ^×S·KĞÜ^ÈcòÊÛÇàôƒŞ§²³Š]NÙ$‚KÈÌ…%Ùg\|Ì@Ez…¬(åšx>ñö$u¤İŠJç›ßh—1ÚO;Goe-»ì[–”‘œ«	Çò­/Ã—“ ¹»º‹ç(ÂœèFßQ]¼ñ¯”Ì¸‰#2ª£7l“ĞÔšÅÏörÇ$ö¥cY:n$uúTó2¹Q…¥iúe‚Imæ_^FfÊÅ“cĞnştíVê×O¸oÌ”o-tû%œç«ŸaÚ§µÒ­5K´›ûF)b+@Å :œujÒ†M6ÿ @±{Æi{x@\û¹ëEÊ+˜¯®n%}&´ø˜+;"ùÇ@=+P›>ÂÁ7¿ëf@Xûë.+ÛÉ™–'µ´V“ˆüÍÒ ì	u©nì*Í{qupdLG9'ÒÏ¯^^‰-í7NÀÛj¡€=Á=ª­ãŞÛÌyll.ìI!šQë…
»mlË,ĞÚZÙ²å«ÿ ZÈ/`×Ÿ¿»2y¤—û; 	õÜ{S^{»gÆéâ“ò}¤ä:”*Í¬¤
÷[Û¨\)Xe³ß'œR_Şiš\SÍböV­$†W"g•‰û«ëÅsŞ*y.nl,oå½³yÑ³G‡rz¨ ˜®tOmÊêHÛÉ2	]ßİ­aÜÛËw˜â3nÈZ5ó2Tw4Äƒ[½T¸²²‘¼ÀXHñÛØ®zT-¤}Œ¥¾³~b
¤‹{oBA‘À¢ÂÅ¬7¨‡oÏ"«on>£ÜWH×öv»ÚÓHË¿Ëy#×=ëyô½(¬±ÙùmŸ”Ê»¦-ØŒñŠu¦½nº¥ìÅÿ t¿½I×zíÔn³%ÕÌ»£³]1äØƒÜ“ÔQaqe‘o58@ù¡±Œù„únáQj>$ŸZw{´Tw°mxÂ÷5›qo|Qn$XˆóÎvõ$v¢Ás ÿ „ºÒË&ËN–Ş2Ùm„9#×uV¼ñŒ×N¾LŞõß¹‰3éQÚiÍlÏq$"2Ã|¥°±ç‘Œvöª³