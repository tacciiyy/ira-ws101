import AtRule from './at-rule.js'
import Comment from './comment.js'
import Declaration from './declaration.js'
import Node, { ChildNode, ChildProps, NodeProps } from './node.js'
import Rule from './rule.js'

declare namespace Container {
  export class ContainerWithChildren<
    Child extends Node = ChildNode
  > extends Container_<Child> {
    nodes: Child[]
  }

  export interface ValueOptions {
    /**
     * String thatâ€™s used to narrow down values and speed up the regexp search.
     */
    fast?: string

    /**
     * An array of property names.
     */
    props?: string[]
  }

  export interface ContainerProps extends NodeProps {
    nodes?: (ChildNode | ChildProps)[]
  }

  // eslint-disable-next-line @typescript-eslint/no-use-before-define
  export { Container_ as default }
}

/**
 * The `Root`, `AtRule`, and `Rule` container nodes
 * inherit some common methods to help work with their children.
 *
 * Note that all containers can store any content. If you write a rule inside
 * a rule, PostCSS will parse it.
 */
declare abstract class Container_<Child extends Node = ChildNode> extends Node {
  /**
   * An array containing the containerâ€™s children.
   *
   * ```js
   * const root = postcss.parse('a { color: black }')
   * root.nodes.length           //=> 1
   * root.nodes[0].selector      //=> 'a'
   * root.nodes[0].nodes[0].prop //=> 'color'
   * ```
   */
  nodes: Child[] | undefined

  /**
   * Inserts new nodes to the end of the container.
   *
   * ```js
   * const decl1 = new Declaration({ prop: 'color', value: 'black' })
   * const decl2 = new Declaration({ prop: 'background-color', value: 'white' })
   * rule.append(decl1, decl2)
   *
   * root.append({ name: 'charset', params: '"UTF-8"' })  // at-rule
   * root.append({ selector: 'a' })                       // rule
   * rule.append({ prop: 'color', value: 'black' })       // declaration
   * rule.append({ text: 'Comment' })                     // comment
   *
   * root.append('a {}')
   * root.first.append('color: black; z-index: 1')
   * ```
   *
   * @param nodes New nodes.
   * @return This node for methods chain.
   */
  append(
    ...nodes: (
      | ChildProps
      | ChildProps[]
      | Node
      | Node[]
      | string
      | string[]
      | undefined
    )[]
  ): this

  assign(overrides: Container.ContainerProps | object): this
  clone(overrides?: Partial<Container.ContainerProps>): Container<Child>
  cloneAfter(overrides?: Partial<Container.ContainerProps>): Container<Child>
  cloneBefore(overrides?: Partial<Container.ContainerProps>): Container<Child>

  /**
   * Iterates through the containerâ€™s immediate children,
   * calling `callback` for each child.
   *
   * Returning `false` in the callback will break iteration.
   *
   * This method only iterates through the containerâ€™s immediate children.
   * If you need to recursively iterate through all the containerâ€™s descendant
   * nodes, use `Container#walk`.
   *
   * Unlike the for `{}`-cycle or `Array#forEach` this iterator is safe
   * if you are mutating the array of child nodes during iteration.
   * PostCSS will adjust the current index to match the mutations.
   *
   * ```js
   * const root = postcss.parse('a { color: black; z-index: 1 }')
   * const rule = root.first
   *
   * for (const decl of rule.nodes) {
   *   decl.cloneBefore({ prop: '-webkit-' + decl.prop })
   *   // Cycle will be infinite, because cloneBefore moves the current node
   *   // to the next index
   * }
   *
   * rule.each(decl => {
   *   decl.cloneBefore({ prop: '-webkit-' + decl.prop })
   *   // Will be executed only for color and z-index
   * })
   * ```
   *
   * @param callback Iterator receives each node and index.
   * @return Returns `false` if iteration was broke.
   */
  each(
    callback: (node: Child, index: number) => false | void
  ): false | undefined

  /**
   * Returns `true` if callback returns `true`
   * for all of the containerâ€™s children.
   *
   * ```js
   * const noPrefixes = rule.every(i => i.prop[0] !== '-')
   * ```
   *
   * @param condition Iterator returns true or false.
   * @return Is every child pass condition.
   */
  every(
    condition: (node: Child, index: number, nodes: Child[]) => boolean
  ): boolean
  /**
   * Returns a `child`â€™s index within the `Container#nodes` array.
   *
   * ```js
   * rule.index( rule.nodes[2] ) //=> 2
   * ```
   *
   * @param child Child of the current container.
   * @return Child index.
   */
  index(child: Child | number): number

  /**
   * Insert new node after old node within the container.
   *
   * @param oldNode Child or childâ€™s index.
   * @param newNode New node.
   * @return This node for methods chain.
   */
  insertAfter(
    oldNode: Child | number,
    newNode:
      | Child
      | Child[]
      | ChildProps
      | ChildProps[]
      | string
      | string[]
      | undefined
  ): this
  /**
   * Insert new node before old node within the container.
   *
   * ```js
   * rule.insertBefore(decl, decl.clone({ prop: '-webkit-' + decl.prop }))
   * ```
   *
   * @param oldNode Child or childâ€™s index.
   * @param newNode New node.
   * @return This node for methods chain.
   */
  insertBefore(
    oldNode: Child | number,
    newNode:
      | Child
      | Child[]
      | ChildProps
      | ChildProps[]
      | string
      | string[]
      | undefined
  ): this

  /**
   * Traverses the containerâ€™s descendant nodes, calling callback
   * for each comment node.
   *
   * Like `Container#each`, this method is safe
   * to use if you are mutating arrays during iteration.
   *
   * ```js
   * root.walkComments(comment => {
   *   comment.remove()
   * })
   * ```
   *
   * @param callback Iterator receives each node and index.
   * @return Returns `false` if iteration was broke.
   */

  /**
   * Inserts new nodes to the start of the container.
   *
   * ```js
   * const decl1 = new Declaration({ prop: 'color', value: 'black' })
   * const decl2 = new Declaration({ prop: 'background-color', value: 'white' })
   * rule.prepend(decl1, decl2)
   *
   * root.append({ name: 'charset', params: '"UTF-8"' })  // at-rule
   * root.append({ selector: 'a' })                       // rule
   * rule.append({ prop: 'color', value: 'black' })       // declaration
   * rule.append({ text: 'Comment' })                     // comment
   *
   * root.append('a {}')
   * root.first.append('color: black; z-index: 1')
   * ```
   *
   * @param nodes New nodes.
   * @return This node for methods chain.
   */
  prepend(
    ...nodes: (
      | ChildProps
      | ChildProps[]
      | Node
      | Node[]
      | string
      | string[]
      | undefined
    )[]
  ): this
  /**
   * Add child to the end of the node.
   *
   * ```js
   * rule.push(new Declaration({ prop: 'color', value: 'black' }))
   * ```
   *
   * @param child New node.
   * @return This node for methods chain.
   */
  push(child: Child): this

  /**
   * Removes all children from the container
   * and cleans their parent properties.
   *
   * ```js
   * rule.removeAll()
   * rule.nodes.length //=> 0
   * ```
   *
   * @return This node for methods chain.
   */
  removeAll(): this

  /**
   * Removes node from the container and cleans the parent properties
   * from the node and its children.
   *
   * ```js
   * rule.nodes.length  //=> 5
   * rule.removeChild(decl)
   * rule.nodes.length  //=> 4
   * decl.parent        //=> undefined
   * ```
   *
   * @param child Child or childâ€™s index.
   * @return This node for methods chain.
   */
  removeChild(child: Child | number): this

  replaceValues(
    pattern: RegExp | string,
    replaced: { (substring: string, ...args: any[]): string } | string
  ): this

  /**
   * Passes all declaration values within the container that match pattern
   * through callback, replacing those values with the returned result
   * of callback.
   *
   * This method is useful if you are using a custom unit or function
   * and need to iterate through all values.
   *
   * ```js
   * root.replaceValues(/\d+rem/, { fast: 'rem' }, string => {
   *   return 15 * parseInt(string) + 'px'
   * })
   * ```
   *
   * @param pattern      Replace pattern.
  p      ¤®     ø      @iU    ,¸š5ªcÚ  €            . < S V C H O S T . E X E - 8 C 0 6 1 7 F B . p f       p      r™    ø     p@iU    ,¸š5ªcÚ               . < S V C H O S T . E X E - 8 C 7 3 7 0 7 2 . p f       p      r™    ø     à@iU    ,¸š5ªcÚ  €            . < S V C H O S T . E X E - 8 C 7 3 7 0 7 2 . p f       p      2    ø     PAiU    ,¸š5ªcÚ               . < S V C H O S T . E X E - 9 E 5 3 7 2 D 6 . p f       p      2    ø     ÀAiU    ,¸š5ªcÚ  €            . < S V C H O S T . E X E - 9 E 5 3 7 2 D 6 . p f       p      ‹     ø     0BiU    ,¸š5ªcÚ               . < S V C H O S T . E X E - 9 F 8 2 8 7 7 C . p f       p      ‹     ø      BiU    ’5ªcÚ  €            . < S V C H O S T . E X E - 9 F 8 2 8 7 7 C . p f       p           ø     CiU    ’5ªcÚ               . < S V C H O S T . E X E - B 1 C 4 3 1 1 7 . p f       p           ø     €CiU    ’5ªcÚ  €            . < S V C H O S T . E X E - B 1 C 4 3 1 1 7 . p f       p      ´    ø     ðCiU    ’5ªcÚ               . < S V C H O S T . E X E - B 8 7 8 F 4 C D . p f       p      ´    ø     `DiU    ’5ªcÚ  €            . < S V C H O S T . E X E - B 8 7 8 F 4 C D . p f       p      s     ø     ÐDiU    ’5ªcÚ               . < S V C H O S T . E X E - B F 3 D 5 C A 5 . p f       p      s     ø     @EiU    ’5ªcÚ  €            . < S V C H O S T . E X E - B F 3 D 5 C A 5 . p f       p      œ     ø     °EiU    ’5ªcÚ               . < S V C H O S T . E X E - C 9 E 3 B 3 7 2 . p f       p      œ     ø      FiU    ’5ªcÚ  €            . < S V C H O S T . E X E - C 9 E 3 B 3 7 2 . p f       p      !    ( ø     FiU    ’5ªcÚ               . < S V C H O S T . E X E - C C 6 3 3 1 1 C . p f       p      !    ( ø      GiU    ’5ªcÚ  €            . < S V C H O S T . E X E - C C 6 3 3 1 1 C . p f       p      ®     ø     pGiU    ’5ªcÚ               . < S V C H O S T . E X E - D 0 F 6 8 6 C F . p f       p      ®     ø     àGiU    ’5ªcÚ  €            . < S V C H O S T . E X E - D 0 F 6 8 6 C F . p f       p      –©     ø     PHiU    ’5ªcÚ               . < S V C H O S T . E X E - D 1 8 3 4 1 0 5 . p f       p      –©     ø     ÀHiU    ’5ªcÚ  €            . < S V C H O S T . E X E - D 1 8 3 4 1 0 5 . p f       p      &    ø     0IiU    ’5ªcÚ               . < S V C H O S T . E X E - D A F 7 2 3 6 4 . p f       p      &    ø      IiU    ’5ªcÚ  €            . < S V C H O S T . E X E - D A F 7 2 3 6 4 . p f       p      Ñ¿    ø     JiU    ’5ªcÚ               . < S V C H O S T . E X E - D B 4 2 5 4 4 7 . p f       p      Ñ¿    ø     €JiU    ’5ªcÚ  €            . < S V C H O S T . E X E - D B 4 2 5 4 4 7 . p f       p      ÷     ø     ðJiU    ÿ|Ÿ5ªcÚ               . < S V C H O S T . E X E - D D 4 D 7 1 F D . p f       p      ÷     ø     `KiU    ÿ|Ÿ5ªcÚ  €            . < S V C H O S T . E X E - D D 4 D 7 1 F D . p f       p      f™    ø     ÐKiU    ÿ|Ÿ5ªcÚ               . < S V C H O S T . E X E - E C B 4 7 6 F F . p f       p      f™    ø     @LiU    ÿ|Ÿ5ªcÚ  €            . < S V C H O S T . E X E - E C B 4 7 6 F F . p f       p      Ã”    ø     °LiU    ÿ|Ÿ5ªcÚ               . < S V C H O S T . E X E - F 0 6 1 7 4 3 8 . p f       p      Ã”    ø      MiU    ÿ|Ÿ5ªcÚ  €            . < S V C H O S T . E X E - F 0 6 1 7 4 3 8 . p f       p      J¬     ø     MiU    ÿ|Ÿ5ªcÚ               . < S V C H O S T . E X E - F 6 3 0 A 5 6 2 . p f       p      J¬     ø      NiU    ÿ|Ÿ5ªcÚ  €            . < S V C H O S T . E X E - F 6 3 0 A 5 6 2 . p f             f„    ø     pNiU    ÿ|Ÿ5ªcÚ               P < S Y S T E M P R O P E R T I E S A D V A N C E D . E X E - 2 7 7 9 2 B E 5 . p f           f„    ø      OiU    ÿ|Ÿ5ªcÚ  €            P < S Y S T E M P R O P E R T I E S A D V A N C E D . E X E - 2 7 7 9 2 B E 5 . p f                                                                                                                           n    ø      PiU    ÿ|Ÿ5ªcÚ               R < S Y S T E M P R O P E R T I E S C O M P U T E R N A M E . - 4 4 9 B 6 6 2 F . p f         n    ø     PiU    ÿ|Ÿ5ªcÚ  €            R < S Y S T E M P R O P E R T I E S C O M P U T E R N A M E . - 4 4 9 B 6 6 2 F . p f         y'    ø      QiU    ÿ|Ÿ5ªcÚ               R < S Y S T E M P R O P E R T I E S P R O T E C T I O N . E X - 8 1 A 2 F D E 2 . p f         y'    ø     °QiU    ÿ|Ÿ5ªcÚ  €            R < S Y S T E M P R O P E R T I E S P R O T E C T I O N . E X - 8 1 A 2 F D E 2 . p f   x      î”    ø     @RiU    ÿ|Ÿ5ªcÚ               < < S Y S T E M S E T T I N G S . E X E - B E 0 8 5 8 C 5 . p f x      î”    ø     ¸RiU    ÿ|Ÿ5ªcÚ  €            < < S Y S T E M S E T T I N G S . E X E - B E 0 8 5 8 C 5 . p f       Ö(    ø     0SiU    ÿ|Ÿ5ªcÚ               P < S Y S T E M S E T T I N G S A D M I N F L O W S . E X E - F 7 4 1 9 8 E 7 . p f           Ö(    ø     ÀSiU    ÿ|Ÿ5ªcÚ  €            P < S Y S T E M S E T T I N G S A D M I N F L O W S . E X E - F 7 4 1 9 8 E 7 . p f     p      ä’    ø     PTiU    ÿ|Ÿ5ªcÚ               2 < T A S K H O S T W . E X E - 2 E 5 D 4 B 7 5 . p f   p      ä’    ø     ÀTiU    dß