 updated by $1Card number updated by $1It'll now expire on $1Your card's expiration date has been updatedExpiration date updatedVirtual card ends in $1Your virtual card has been generated.Virtual card generatedTotal pointsTrack orderAutomatically track your order when you purchase from certain sitesWallet helps track your orderRemoving Crypto Wallet fails. Please try it againTo update billing address, go to your $1
      .All set! Your billing information has been updatedUnable to update card's address. Please check the information is correct and try again.To update this card, enter the CVV security code associated with your $1 ending in $2.All set! Your nickname has been updated.All set! Your virtual card has been updatedUpdating billing information…Updating virtual card…Use this virtual card when making purchases on Microsoft Edge.Verify and enrolWhen shopping online, Edge can substitute your card number with a virtual card number. If the merchant has a data breach, this can help protect your true card details. Your card issuer may send you a verification code.Check out safely with virtual card?View historyVirtual card historyRefresh nowAn update is available for Wallet. Please refresh this page to use the latest version.Order trackingBuy now pay laterLearn more about $1Did this feature help with your shopping experience?Learn more how buy now pay later worksMicrosoft does not charge you or get paid by this provider for this transaction $1. By continuing you agree to $2 and acknowledge that your total purchase amount will be shared with the selected provider in accordance with $3.Estimated fees1st paymentThis is the estimated due date for the first payment. Actual date may vary based on when the merchant processes your purchase.Manage your autofill optionsNo. paymentsMicrosoft's Privacy Statement$1 isn't available for this purchaseOnly purchases between $1-$2 are eligibleEnter your details and select a providerSelect an option:Microsoft's Terms of UseOrder total, including taxes and shipping:Enter amountEnter total order amount including taxes and shippingVirtual card readyWe are unable to retrieve your virtual card details. Please visit $1 for your virtual card details.Uh ohVisit $1Thank you for your feedback.If you have recently been approved for a transaction by Affirm, the payment terms with that approval may apply.$1 also offers monthly payments with interest.Postcode also offers monthly payments with interest.Microsoft does not charge you or get paid by these providers.Purchase will be split into 4 instalmentsPurchase can be split into 4 instalmentschange your settingsSatisfied with Wallet?Auto apply your gift card to this order. Check your email for the gift card number, then enter it manually to use it.We couldn't automatically apply your gift card to this order. Check your email for the gift card number, then enter it manually to use it.We couldn't redeem your Rewards points as a gift card. You can continue with the order or try the transaction again later.Redeem your Rewards points as a gift card.Pay over timeBilling address is the same as shipping addressThis website doesn't support virtual cardVirtual card number •••• $1 activated to protect your payment informationSplit payments over 8 weeksBuy now, pay over time with Affirm.No interest fees, late fees may applyShop now. Pay over time with Klarna.Select shipping addressPay by cardSelect payment methodPay by card or pay over timeapply savingsNo late fees, no interestNo impact on credit score, late fees may applySplit payments over 6 weeksWallet tested all coupons but didn't find any savingsWallet tested all available couponsYou're saving $1Get up to $1 with $2Up to $1Apply savingsActivate Microsoft CashbackActivate Microsoft Cashback and apply coupons automatically$1 to save time and money when you shop online.Apply coupons automaticallyTurn on shopping in Microsoft EdgeAverage savings: $1 on $2Wallet will find the best offer for you$1 will be testedDon't worry, you can still continue your transaction.The following features aren't available right now:Cash backYou will get up to $1 in cash back.You'll save $1 and will get up to $2 in cash back.Autofill detailsAutofill couldn't complete all your details. Enter them manually to continue your transaction.We automatically filled your payment details for a quick checkout.Applying the best coupon we found…Coupon testing isn't available right now, but you can still test coupons manually.Test couponsTrying $1…$1 available pointsSkip coupons45% of users saved with couponsCoupons applying cancelledWe couldn't activate cash back for this purchase, try again later.See offer details on $1Cash back and couponsCashback couldn't be applied to your purchase right now. Try again later.Activate cashbackYou'll receive email updates and track cash back detail on $1.Apply savings and continueBy continuing, we'll activate the cashback programme, automatically apply coupons, and fill in your shipping and billing information.By continuing, we'll activate the cashback programme, automatically apply coupons, and autofill your shipping and take you to $1By continuing, we'll activate the cashback programme and fill in your shipping and billing information.By continuing, we'll activate the cashback programme and autofill your shipping and take you to $1By continuing, we'll activate the cashback programme and automatically apply coupons.By continuing, we'll activate the cashback programme.On average saved $1Enjoy the rest of your shopping journey.Find the best deals with coupons and cash back, all before you pay.Save money and time with Wallet in Microsoft EdgeYou can get up to $1 cashback on $2Gift cardEnter your CVC to continueTry again and enter your CVC when prompted. Or, select another payment method to continue.activate the cashback programmeautomatically apply couponsautofill your shipping informationfill in your shipping and billing informationfill in your billing informationredeem gift cardtake you to $1By continuing, we'll $1, $2, $3, $4 and $5.By continuing, we'll $1, $2, $3 and $4.By continuing, we'll $1.By continuing, we'll $1, $2 and $3.By continuing, we'll $1 and $2.Shipping detailsYou've already saved $1 with the best coupon and gift cardThe autofill couldn't complete all your details. Just enter them manually to complete your purchase.The cash back couldn't be applied to your purchase right now, try again later.The coupon testing isn't available right now, but you can still test coupons manually.We couldn't apply your gift card to this purchase. $1View gift card statusThe $1, $2, $3, $4 and $5 aren't available right now. Don't worry, you can still complete your transaction.The $1, $2, $3 and $4 aren't available right now. Don't worry, you can still complete your transaction.The $1, $2 and $3 aren't available right now. Don't worry, you can still complete your transaction.The $1 and $2 aren't available right now. Don't worry, you can still complete your transaction.Sorry, we can't help out right nowWe didn't find any working couponsgift cardautofillSome of your details were filled in. Enter the remaining info to complete your purchaseYour checkout details were filled inYou'll get up to $1 in cash back $2You've already saved $1 with the best couponYou've already saved $1 with gift cardNo Saved AddressNo Saved NameWe've applied the best savings for you and found that you can use only one for this purchase. Select one of the below to continue.Choose one to continueClose the pane and return to checkout pageDo not redeem rewards pointsNo gift card selected$1/$2 pointsRedeem $1 gift cardMicrosoft Rewards gift cardApply savings and fill details$1 to activate the cashback and apply coupons automatically. This can save you time and money when you shop on Edge.You're using Microsoft shopping cash back and coupons.and couponsYou're using Microsoft shopping cash back$1.Turn on to enable autofillSkipping coupons…We are connecting with your bank to generate card details for this transaction. This may take a few seconds.Unable to generate virtual card details, please try again or choose another card.Open passwordsOpen payment methodsOpen personal infoStay organised and in control.Manage your memberships in WalletYour card is expiring soonVirtual cards are single-use payment credentials that are randomly generated each time you make an online purchase. This helps ensure your $1 is protected.Protect your card detailsSet up a virtual card to make online shopping safer and more convenient.Set up a virtual card to make online shopping safer and earn 20 Microsoft Rewards points.Set up for $1Protect your purchases with virtual cardsSet upExplore Web3 securely with this non-custodial walletSet up your Crypto WalletDismiss permanentlyYou will not see this notification againCheck it outView your entire giving summary and moreYour booking date of $1 from $2 to $3 is forthcoming.Forthcoming accommodation$1 of your $2 passwords are leaked.Password leakageOrder status updatedMicrosoft Edge detected that $1 of your passwords were found in a known online leak.Password compromiseYour selected $1 Microsoft Cashback offer expires in $2Offer expiring soonTransfer to PaypalCongratulations you have $1 in cashback. Cashout using PayPal.Know more about cashback programme and cash-out using PayPal.It's time to cash out!Save the cardSave card to Microsoft accountSave the card to Microsoft accountPay faster and from different devices on future purchasesPay faster from any deviceNotification snoozed for 7 daysNotification snoozed for $1 daysWallet helps you track your order when you buy from certain sites.Track your orderCard updated successfully!Update nowUpdate or remove cardUpdate failed. Try again in $1Edit your card information to continue use of your card ending in $1.Update your card ending in $1 to continue using it.Try the new management experience in Wallet.Manage your passwords in WalletEarn $1 cash back with $2.Offer expires inAdd new membershipEarn up to 20 rewards points by adding new memberships to walletAdd memberships to earn Microsoft RewardsMicrosoft Edge Terms of UseBuy now, pay over time with Affirm. $1Contact AffirmThe Affirm Card is a limited use virtual card and funded by either Cross River Bank, Member FDIC or Affirm Loan Services, LLC, depending on the terms of your loan agreement, and issued by Sutton Bank, Member FDIC, pursuant to licence from Visa U.S.A. Inc. The Affirm Card is issued by Marqeta. $1 if you have any questions.No late fees applyBuy now, pay over time with AffirmBy continuing, you agree to $1 and acknowledge that your total purchase amount along with where you shop will be shared with Affirm, in accordance with $2. If you have recently been approved for a transaction by Affirm, the payment terms with that approval may apply.Sign in to your online banking app to receive a verification code.Call your bank at $1 to receive a verification code.Your bank is sending you a verification code to your email address $1.Enter the code you received from your bank below.Your bank will call your device number $1 with a verification code.Your bank is sending you a verification code to your device number $1.See if you qualify to pay over timeAutofill did not workTook too much timeShop now. Pay over time with Klarna. $1The Klarna Visa® Commercial Card is issued by Sutton Bank, Member FDIC, pursuant to a licence from Visa U.S.A Inc. The Klarna Card is powered by Marqeta. Customer Service $1Klarna service and late fees may applyKlarna Pay Later in $1Save money with Klarna.By continuing, you agree to $1 and acknowledge that your total purchase amount along with where you shop will be shared with Klarna, in accordance with $2. If you have recently been approved for a transaction by Klarna, the payment terms with that approval may apply.Manage your payment methodsBy continuing, you agree to the $1, $2, and $3 regarding how your data is handled.Go to next pageGo to page $1Go to previous pageEnrolPay safely with a virtual cardSet up a virtual card and earn 20 Microsoft Rewards pointsYour card issuer may send a verification code or request the card's security code to verify it's you.A virtual card hides your card details from merchants when you shop online. If name) === undefined ? defaultValue : self._getOptionValue(name));
    }

    // unassigned or boolean value
    if (typeof self._getOptionValue(name) === 'boolean' || typeof self._getOptionValue(name) === 'undefined') {
      // if no value, negate false, and we have a default, then use it!
      if (val == null) {
        self._setOptionValue(name, option.negate
          ? false
          : defaultValue || true);
      } else {
        self._setOptionValue(name, val);
      }
    } else if (val !== null) {
      // reassign
      self._setOptionValue(name, option.negate ? false : val);
    }
  });

  return this;
};

/**
 * Define option with `flags`, `description` and optional
 * coercion `fn`.
 *
 * The `flags` string should contain both the short and long flags,
 * separated by comma, a pipe or space. The following are all valid
 * all will output this way when `--help` is used.
 *
 *    "-p, --pepper"
 *    "-p|--pepper"
 *    "-p --pepper"
 *
 * Examples:
 *
 *     // simple boolean defaulting to undefined
 *     program.option('-p, --pepper', 'add pepper');
 *
 *     program.pepper
 *     // => undefined
 *
 *     --pepper
 *     program.pepper
 *     // => true
 *
 *     // simple boolean defaulting to true (unless non-negated option is also defined)
 *     program.option('-C, --no-cheese', 'remove cheese');
 *
 *     program.cheese
 *     // => true
 *
 *     --no-cheese
 *     program.cheese
 *     // => false
 *
 *     // required argument
 *     program.option('-C, --chdir <path>', 'change the working directory');
 *
 *     --chdir /tmp
 *     program.chdir
 *     // => "/tmp"
 *
 *     // optional argument
 *     program.option('-c, --cheese [type]', 'add cheese [marble]');
 *
 * @param {String} flags
 * @param {String} description
 * @param {Function|*} [fn] - custom option processing function or default vaue
 * @param {*} [defaultValue]
 * @return {Command} for chaining
 * @api public
 */

Command.prototype.option = function(flags, description, fn, defaultValue) {
  return this._optionEx({}, flags, description, fn, defaultValue);
};

/*
 * Add a required option which must have a value after parsing. This usually means
 * the option must be specified on the command line. (Otherwise the same as .option().)
 *
 * The `flags` string should contain both the short and long flags, separated by comma, a pipe or space.
 *
 * @param {String} flags
 * @param {String} description
 * @param {Function|*} [fn] - custom option processing function or default vaue
 * @param {*} [defaultValue]
 * @return {Command} for chaining
 * @api public
 */

Command.prototype.requiredOption = function(flags, description, fn, defaultValue) {
  return this._optionEx({ mandatory: true }, flags, description, fn, defaultValue);
};

/**
 * Allow unknown options on the command line.
 *
 * @param {Boolean} arg if `true` or omitted, no error will be thrown
 * for unknown options.
 * @api public
 */
Command.prototype.allowUnknownOption = function(arg) {
  this._allowUnknownOption = arguments.length === 0 || arg;
  return this;
};

/**
  * Whether to store option values as properties on command object,
  * or store separately (specify false). In both cases the option values can be accessed using .opts().
  *
  * @param {boolean} value
  * @return {Command} Command for chaining
  * @api public
  */

Command.prototype.storeOptionsAsProperties = function(value) {
  this._storeOptionsAsProperties = (value === undefined) || value;
  if (this.options.length) {
    // This is for programmer, not end user.
    console.error('Commander usage error: call storeOptionsAsProperties before adding options');
  }
  return this;
};

/**
  * Whether to pass command to action handler,
  * or just the options (specify false).
  *
  * @param {boolean} value
  * @return {Command} Command for chaining
  * @api public
  */

Command.prototype.passCommandToAction = function(value) {
  this._passCommandToAction = (value === undefined) || value;
  return this;
};

/**
 * Store option value
 *
 * @param {String} key
 * @param {Object} value
 * @api private
 */

Command.prototype._setOptionValue = function(key, value) {
  if (this._storeOptionsAsProperties) {
    this[key] = value;
  } else {
    this._optionValues[key] = value;
  }
};

/**
 * Retrieve option value
 *
 * @param {String} key
 * @return {Object} value
 * @api private
 */

Command.prototype._getOptionValue = function(key) {
  if (this._storeOptionsAsProperties) {
    return this[key];
  }
  return this._optionValues[key];
};

/**
 * Parse `argv`, setting options and invoking commands when defined.
 *
 * @param {Array} argv
 * @return {Command} for chaining
 * @api public
 */

Command.prototype.parse = function(argv) {
  // implicit help
  if (this.executables) this.addImplicitHelpCommand();

  // store raw args
  this.rawArgs = argv;

  // guess name
  this._name = this._name || basename(argv[1], '.js');

  // github-style sub-commands with no sub-command
  if (this.executables && argv.length < 3 && !this.defaultExecutable) {
    // this user needs help
    argv.push(this._helpLongFlag);
  }

  // process argv
  var normalized = this.normalize(argv.slice(2));
  var parsed = this.parseOptions(normalized);
  var args = this.args = parsed.args;

  var result = this.parseArgs(this.args, parsed.unknown);

  if (args[0] === 'help' && args.length === 1) this.help();

  // Note for future: we could return early if we found an action handler in parseArgs, as none of following code needed?

  // <cmd> --help
  if (args[0] === 'help') {
    args[0] = args[1];
    args[1] = this._helpLongFlag;
  } else {
    // If calling through to executable subcommand we could check for help flags before failing,
    // but a somewhat unlikely case since program options not passed to executable subcommands.
    // Wait for reports to see if check needed and what usage pattern is.
    this._checkForMissingMandatoryOptions();
  }

  // executable sub-commands
  // (Debugging note for future: args[0] is not right if an action has been called)
  var name = result.args[0];
  var subCommand = null;

  // Look for subcommand
  if (name) {
    subCommand = this.commands.find(function(command) {
      return command._name === name;
    });
  }

  // Look for alias
  if (!subCommand && name) {
    subCommand = this.commands.find(function(command) {
      return command.alias() === name;
    });
    if (subCommand) {
      name = subCommand._name;
      args[0] = name;
    }
  }

  // Look for default subcommand
  if (!subCommand && this.defaultExecutable) {
    name = this.defaultExecutable;
    args.unshift(name);
    subCommand = this.commands.find(function(command) {
      return command._name === name;
    });
  }

  if (this._execs.has(name)) {
    return this.executeSubCommand(argv, args, parsed.unknown, subCommand ? subCommand._executableFile : undefined);
  }

  return result;
};

/**
 * Parse `argv`, setting options and invoking commands when defined.
 *
 * Use parseAsync instead of parse if any of your action handlers are async. Returns a Promise.
 *
 * @param {Array} argv
 * @return {Promise}
 * @api public
 */
Command.prototype.parseAsync = function(argv) {
  this.parse(argv);
  return Promise.all(this._actionResults);
};

/**
 * Execute a sub-command executable.
 *
 * @param {Array} argv
 * @param {Array} args
 * @param {Array} unknown
 * @param {String} executableFile
 * @api private
 */

Command.prototype.executeSubCommand = function(argv, args, unknown, executableFile) {
  args = args.concat(unknown);

  if (!args.length) this.help();

  var isExplicitJS = false; // Whether to use node to launch "executable"

  // executable
  var pm = argv[1];
  // name of the subcommand, like `pm-install`
  var bin = basename(pm, path.extname(pm)) + '-' + args[0];
  if (executableFile != null) {
    bin = executableFile;
    // Check for same extensions as we scan for below so get consistent launch behaviour.
    var executableExt = path.extname(executableFile);
    isExplicitJS = executableExt === '.js' || executableExt === '.ts' || executableExt === '.mjs';
  }

  // In case of globally installed, get the base dir where executable
  //  subcommand file should be located at
  var baseDir;

  var resolvedLink = fs.realpathSync(pm);

  baseDir = dirname(resolvedLink);

  // prefer local `./<bin>` to bin in the $PATH
  var localBin = path.join(baseDir, bin);

  // whether bin file is a js script with explicit `.js` or `.ts` extension
  if (exists(localBin + '.js')) {
    bin = localBin + '.js';
    isExplicitJS = true;
  } else if (exists(localBin + '.ts')) {
    bin = localBin + '.ts';
    isExplicitJS = true;
  } else if (exists(localBin + '.mjs')) {
    bin = localBin + '.mjs';
    isExplicitJS = true;
  } else if (exists(localBin)) {
    bin = localBin;
  }

  args = args.slice(1);

  var proc;
  if (process.platform !== 'win32') {
    if (isExplicitJS) {
      args.unshift(bin);
      // add executable arguments to spawn
      args = incrementNodeInspectorPort(process.execArgv).concat(args);

      proc = spawn(process.argv[0], args, { stdio: 'inherit' });
    } else {
      proc = spawn(bin, args, { stdio: 'inherit' });
    }
  } else {
    args.unshift(bin);
    // add executable arguments to spawn
    args = incrementNodeInspectorPort(process.execArgv).concat(args);
    proc = spawn(process.execPath, args, { stdio: 'inherit' });
  }

  var signals = ['SIGUSR1', 'SIGUSR2', 'SIGTERM', 'SIGINT', 'SIGHUP'];
  signals.forEach(function(signal) {
    process.on(signal, function() {
      if (proc.killed === false && proc.exitCode === null) {
        proc.kill(signal);
      }
    });
  });

  // By default terminate process when spawned process terminates.
  // Suppressing the exit if exitCallback defined is a bit messy and of limited use, but does allow process to stay running!
  const exitCallback = this._exitCallback;
  if (!exitCallback) {
    proc.on('close', process.exit.bind(process));
  } else {
    proc.on('close', () => {
      exitCallback(new CommanderError(process.exitCode || 0, 'commander.executeSubCommandAsync', '(close)'));
    });
  }
  proc.on('error', function(err) {
    if (err.code === 'ENOENT') {
      console.error('error: %s(1) does not exist, try --help', bin);
    } else if (err.code === 'EACCES') {
      console.error('error: %s(1) not executable. try chmod or run with root', bin);
    }
    if (!exitCallback) {
      process.exit(1);
    } else {
      const wrappedError = new CommanderError(1, 'commander.executeSubCommandAsync', '(error)');
      wrappedError.nestedError = err;
      exitCallback(wrappedError);
    }
  });

  // Store the reference to the child process
  this.runningCommand = proc;
};

/**
 * Normalize `args`, splitting joined short flags. For example
 * the arg "-abc" is equivalent to "-a -b -c".
 * This also normalizes equal sign and splits "--abc=def" into "--abc def".
 *
 * @param {Array} args
 * @return {Array}
 * @api private
 */

Command.prototype.normalize = function(args) {
  var ret = [],
    arg,
    lastOpt,
    index,
    short,
    opt;

  for (var i = 0, len = args.length; i < len; ++i) {
    arg = args[i];
    if (i > 0) {
      lastOpt = this.optionFor(args[i - 1]);
    }

    if (arg === '--') {
      // Honor option terminator
      ret = ret.concat(args.slice(i));
      break;
    } else if (lastOpt && lastOpt.required) {
      ret.push(arg);
    } else if (arg.length > 2 && arg[0] === '-' && arg[1] !== '-') {
      short = arg.slice(0, 2);
      opt = this.optionFor(short);
      if (opt && (opt.required || opt.optional)) {
        ret.push(short);
        ret.push(arg.slice(2));
      } else {
        arg.slice(1).split('').forEach(function(c) {
          ret.push('-' + c);
        });
      }
    } else if (/^--/.test(arg) && ~(index = arg.indexOf('='))) {
      ret.push(arg.slice(0, index), arg.slice(index + 1));
    } else {
      ret.push(arg);
    }
  }

  return ret;
};

/**
 * Parse command `args`.
 *
 * When listener(s) are available those
 * callbacks are invoked, otherwise the "*"
 * event is emitted and those actions are invoked.
 *
 * @param {Array} args
 * @return {Command} for chaining
 * @api private
 */

Command.prototype.parseArgs = function(args, unknown) {
  var name;

  if (args.length) {
    name = args[0];
    if (this.listeners('command:' + name).length) {
      this.emit('command:' + args.shift(), args, unknown);
    } else {
      this.emit('command:*', args, unknown);
    }
  } else {
    outputHelpIfRequested(this, unknown);

    // If there were no args and we have unknown options,
    // then they are extraneous and we need to error.
    if (unknown.length > 0 && !this.defaultExecutable) {
      this.unknownOption(unknown[0]);
    }
    if (this.commands.length === 0 &&
        this._args.filter(function(a) { return a.required; }).length === 0) {
      this.emit('command:*');
    }
  }

  return this;
};

/**
 * Return an option matching `arg` if any.
 *
 * @param {String} arg
 * @return {Option}
 * @api private
 */

Command.prototype.optionFor = function(arg) {
  for (var i = 0, len = this.options.length; i < len; ++i) {
    if (this.options[i].is(arg)) {
      return this.options[i];
    }
  }
};

/**
 * Display an error message if a mandatory option does not have a value.
 *
 * @api private
 */

Command.prototype._checkForMissingMandatoryOptions = function() {
  // Walk up hierarchy so can call from action handler after checking for displaying help.
  for (var cmd = this; cmd; cmd = cmd.parent) {
    cmd.options.forEach((anOption) => {
      if (anOption.mandatory && (cmd._getOptionValue(anOption.attributeName()) === undefined)) {
        cmd.missingMandatoryOptionValue(anOption);
      }
    });
  }
};

/**
 * Parse options from `argv` returning `argv`
 * void of these options.
 *
 * @param {Array} argv
 * @return {{args: Array, unknown: Array}}
 * @api public
 */

Command.prototype.parseOptions = function(argv) {
  var args = [],
    len = argv.length,
    literal,
    option,
    arg;

  var unknownOptions = [];

  // parse options
  for (var i = 0; i < len; ++i) {
    arg = argv[i];

    // literal args after --
    if (literal) {
      args.push(arg);
      continue;
    }

    if (arg === '--') {
      literal = true;
      continue;
    }

    // find matching Option
    option = this.optionFor(arg);

    // option is defined
    if (option) {
      // requires arg
      if (option.required) {
        arg = argv[++i];
        if (arg == null) return this.optionMissingArgument(option);
        this.emit('option:' + option.name(), arg);
      // optional arg
      } else if (option.optional) {
        arg = argv[i + 1];
        if (arg == null || (arg[0] === '-' && arg !== '-')) {
          arg = null;
        } else {
          ++i;
        }
        this.emit('option:' + option.name(), arg);
      // flag
      } else {
        this.emit('option:' + option.name());
      }
      continue;
    }

    // looks like an option
    if (arg.length > 1 && arg[0] === '-') {
      unknownOptions.push(arg);

      // If the next argument looks like it might be
      // an argument for this option, we pass it on.
      // If it isn't, then it'll simply be ignored
      if ((i + 1) < argv.length && (argv[i + 1][0] !== '-' || argv[i + 1] === '-')) {
        unknownOptions.push(argv[++i]);
      }
      continue;
    }

    // arg
    args.push(arg);
  }

  return { args: args, unknown: unknownOptions };
};

/**
 * Return an object containing options as key-value pairs
 *
 * @return {Object}
 * @api public
 */
Command.prototype.opts = function() {
  if (this._storeOptionsAsProperties) {
    // Preserve original behaviour so backwards compatible when still using properties
    var result = {},
      len = this.options.length;

    for (var i = 0; i < len; i++) {
      var key = this.options[i].attributeName();
      result[key] = key === this._versionOptionName ? this._version : this[key];
    }
    return result;
  }

  return this._optionValues;
};

/**
 * Argument `name` is missing.
 *
 * @param {String} name
 * @api private
 */

Command.prototype.missingArgument = function(name) {
  const message = `error: missing required argument '${name}'`;
  console.error(message);
  this._exit(1, 'commander.missingArgument', message);
};

/**
 * `Option` is missing an argument, but received `flag` or nothing.
 *
 * @param {Option} option
 * @param {String} [flag]
 * @api private
 */

Command.prototype.optionMissingArgument = function(option, flag) {
  let message;
  if (flag) {
    message = `error: option '${option.flags}' argument missing, got '${flag}'`;
  } else {
    message = `error: option '${option.flags}' argument missing`;
  }
  console.error(message);
  this._exit(1, 'commander.optionMissingArgument', message);
};

/**
 * `Option` does not have a value, and is a mandatory option.
 *
 * @param {Option} option
 * @api private
 */

Command.prototype.missingMandatoryOptionValue = function(option) {
  const message = `error: required option '${option.flags}' not specified`;
  console.error(message);
  this._exit(1, 'commander.missingMandatoryOptionValue', message);
};

/**
 * Unknown option `flag`.
 *
 * @param {String} flag
 * @api private
 */

Command.prototype.unknownOption = function(flag) {
  if (this._allowUnknownOption) return;
  const message = `error: unknown option '${flag}'`;
  console.error(message);
  this._exit(1, 'commander.unknownOption', message);
};

/**
 * Variadic argument with `name` is not the last argument as required.
 *
 * @param {String} name
 * @api private
 */

Command.prototype.variadicArgNotLast = function(name) {
  const message = `error: variadic arguments must be last '${name}'`;
  console.error(message);
  this._exit(1, 'commander.variadicArgNotLast', message);
};

/**
 * Set the program version to `str`.
 *
 * This method auto-registers the "-V, --version" flag
 * which will print the version number when passed.
 *
 * You can optionally supply the  flags and description to override the defaults.
 *
 * @param {String} str
 * @param {String} [flags]
 * @param {String} [description]
 * @return {Command} for chaining
 * @api public
 */

Command.prototype.version = function(str, flags, description) {
  if (arguments.length === 0) return this._version;
  this._version = str;
  flags = flags || '-V, --version';
  description = description || 'output the version number';
  var versionOption = new Option(flags, description);
  this._versionOptionName = versionOption.long.substr(2) || 'version';
  this.options.push(versionOption);
  var self = this;
  this.on('option:' + this._versionOptionName, function() {
    process.stdout.write(str + '\n');
    self._exit(0, 'commander.version', str);
  });
  return this;
};

/**
 * Set the description to `str`.
 *
 * @param {String} str
 * @param {Object} [argsDescription]
 * @return {String|Command}
 * @api public
 */

Command.prototype.description = function(str, argsDescription) {
  if (arguments.length === 0) return this._description;
  this._description = str;
  this._argsDescription = argsDescription;
  return this;
};

/**
 * Set an alias for the command
 *
 * @param {String} alias
 * @return {String|Command}
 * @api public
 */

Command.prototype.alias = function(alias) {
  var command = this;
  if (this.commands.length !== 0) {
    command = this.commands[this.commands.length - 1];
  }

  if (arguments.length === 0) return command._alias;

  if (alias === command._name) throw new Error('Command alias can\'t be the same as its name');

  command._alias = alias;
  return this;
};

/**
 * Set / get the command usage `str`.
 *
 * @param {String} [str]
 * @return {String|Command}
 * @api public
 */

Command.prototype.usage = function(str) {
  var args = this._args.map(function(arg) {
    return humanReadableArgName(arg);
  });

  var usage = '[options]' +
    (this.commands.length ? ' [command]' : '') +
    (this._args.length ? ' ' + args.join(' ') : '');

  if (arguments.length === 0) return this._usage || usage;
  this._usage = str;

  return this;
};

/**
 * Get or set the name of the command
 *
 * @param {String} [str]
 * @return {String|Command}
 * @api public
 */

Command.prototype.name = function(str) {
  if (arguments.length === 0) return this._name;
  this._name = str;
  return this;
};

/**
 * Return prepared commands.
 *
 * @return {Array}
 * @api private
 */

Command.prototype.prepareCommands = function() {
  return this.commands.filter(function(cmd) {
    return !cmd._noHelp;
  }).map(function(cmd) {
    var args = cmd._args.map(function(arg) {
      return humanReadableArgName(arg);
    }).join(' ');

    return [
      cmd._name +
        (cmd._alias ? '|' + cmd._alias : '') +
        (cmd.options.length ? ' [options]' : '') +
        (args ? ' ' + args : ''),
      cmd._description
    ];
  });
};

/**
 * Return the largest command length.
 *
 * @return {Number}
 * @api private
 */

Command.prototype.largestCommandLength = function() {
  var commands = this.prepareCommands();
  return commands.reduce(function(max, command) {
    return Math.max(max, command[0].length);
  }, 0);
};

/**
 * Return the largest option length.
 *
 * @return {Number}
 * @api private
 */

Command.prototype.largestOptionLength = function() {
  var options = [].slice.call(this.options);
  options.push({
    flags: this._helpFlags
  });

  return options.reduce(function(max, option) {
    return Math.max(max, option.flags.length);
  }, 0);
};

/**
 * Return the largest arg length.
 *
 * @return {Number}
 * @api private
 */

Command.prototype.largestArgLength = function() {
  return this._args.reduce(function(max, arg) {
    return Math.max(max, arg.name.length);
  }, 0);
};

/**
 * Return the pad width.
 *
 * @return {Number}
 * @api private
 */

Command.prototype.padWidth = function() {
  var width = this.largestOptionLength();
  if (this._argsDescription && this._args.length) {
    if (this.largestArgLength() > width) {
      width = this.largestArgLength();
    }
  }

  if (this.commands && this.commands.length) {
    if (this.largestCommandLength() > width) {
      width = this.largestCommandLength();
    }
  }

  return width;
};

/**
 * Return help for options.
 *
 * @return {String}
 * @api private
 */

Command.prototype.optionHelp = function() {
  var width = this.padWidth();

  var columns = process.stdout.columns || 80;
  var descriptionWidth = columns - width - 4;

  // Append the help information
  return this.options.map(function(option) {
    const fullDesc = option.description +
      ((!option.negate && option.defaultValue !== undefined) ? ' (default: ' + JSON.stringify(option.defaultValue) + ')' : '');
    return pad(option.flags, width) + '  ' + optionalWrap(fullDesc, descriptionWidth, width + 2);
  }).concat([pad(this._helpFlags, width) + '  ' + optionalWrap(this._helpDescription, descriptionWidth, width + 2)])
    .join('\n');
};

/**
 * Return command help documentation.
 *
 * @return {String}
 * @api private
 */

Command.prototype.commandHelp = function() {
  if (!this.commands.length) return '';

  var commands = this.prepareCommands();
  var width = this.padWidth();

  var columns = process.stdout.columns || 80;
  var descriptionWidth = columns - width - 4;

  return [
    'Commands:',
    commands.map(function(cmd) {
      var desc = cmd[1] ? '  ' + cmd[1] : '';
      return (desc ? pad(cmd[0], width) : cmd[0]) + optionalWrap(desc, descriptionWidth, width + 2);
    }).join('\n').replace(/^/gm, '  '),
    ''
  ].join('\n');
};

/**
 * Return program help documentation.
 *
 * @return {String}
 * @api private
 */

Command.prototype.helpInformation = function() {
  var desc = [];
  if (this._description) {
    desc = [
      this._description,
      ''
    ];

    var argsDescription = this._argsDescription;
    if (argsDescription && this._args.length) {
      var width = this.padWidth();
      var columns = process.stdout.columns || 80;
      var descriptionWidth = columns - width - 5;
      desc.push('Arguments:');
      desc.push('');
      this._args.forEach(function(arg) {
        desc.push('  ' + pad(arg.name, width) + '  ' + wrap(argsDescription[arg.name], descriptionWidth, width + 4));
      });
      desc.push('');
    }
  }

  var cmdName = this._name;
  if (this._alias) {
    cmdName = cmdName + '|' + this._alias;
  }
  var parentCmdNames = '';
  for (var parentCmd = this.parent; parentCmd; parentCmd = parentCmd.parent) {
    parentCmdNames = parentCmd.name() + ' ' + parentCmdNames;
  }
  var usage = [
    'Usage: ' + parentCmdNames + cmdName + ' ' + this.usage(),
    ''
  ];

  var cmds = [];
  var commandHelp = this.commandHelp();
  if (commandHelp) cmds = [commandHelp];

  var options = [
    'Options:',
    '' + this.optionHelp().replace(/^/gm, '  '),
    ''
  ];

  return usage
    .concat(desc)
    .concat(options)
    .concat(cmds)
    .join('\n');
};

/**
 * Output help information for this command.
 *
 * When listener(s) are available for the helpLongFlag
 * those callbacks are invoked.
 *
 * @api public
 */

Command.prototype.outputHelp = function(cb) {
  if (!cb) {
    cb = function(passthru) {
      return passthru;
    };
  }
  const cbOutput = cb(this.helpInformation());
  if (typeof cbOutput !== 'string' && !Buffer.isBuffer(cbOutput)) {
    throw new Error('outputHelp callback must return a string or a Buffer');
  }
  process.stdout.write(cbOutput);
  this.emit(this._helpLongFlag);
};

/**
 * You can pass in flags and a description to override the help
 * flags and help description for your command.
 *
 * @param {String} [flags]
 * @param {String} [description]
 * @return {Command}
 * @api public
 */

Command.prototype.helpOption = function(flags, description) {
  this._helpFlags = flags || this._helpFlags;
  this._helpDescription = description || this._helpDescription;

  var splitFlags = this._helpFlags.split(/[ ,|]+/);

  if (splitFlags.length > 1) this._helpShortFlag = splitFlags.shift();

  this._helpLongFlag = splitFlags.shift();

  return this;
};

/**
 * Output help information and exit.
 *
 * @param {Function} [cb]
 * @api public
 */

Command.prototype.help = function(cb) {
  this.outputHelp(cb);
  // exitCode: preserving original behaviour which was calling process.exit()
  // message: do not have all displayed text available so only passing placeholder.
  this._exit(process.exitCode || 0, 'commander.help', '(outputHelp)');
};

/**
 * Camel-case the given `flag`
 *
 * @param {String} flag
 * @return {String}
 * @api private
 */

function camelcase(flag) {
  return flag.split('-').reduce(function(str, word) {
    return str + word[0].toUpperCase() + word.slice(1);
  });
}

/**
 * Pad `str` to `width`.
 *
 * @param {String} str
 * @param {Number} width
 * @return {String}
 * @api private
 */

function pad(str, width) {
  var len = Math.max(0, width - str.length);
  return str + Array(len + 1).join(' ');
}

/**
 * Wraps the given string with line breaks at the specified width while breaking
 * words and indenting every but the first line on the left.
 *
 * @param {String} str
 * @param {Number} width
 * @param {Number} indent
 * @return {String}
 * @api private
 */
function wrap(str, width, indent) {
  var regex = new RegExp('.{1,' + (width - 1) + '}([\\s\u200B]|$)|[^\\s\u200B]+?([\\s\u200B]|$)', 'g');
  var lines = str.match(regex) || [];
  return lines.map(function(line, i) {
    if (line.slice(-1) === '\n') {
      line = line.slice(0, line.length - 1);
    }
    return ((i > 0 && indent) ? Array(indent + 1).join(' ') : '') + line.trimRight();
  }).join('\n');
}

/**
 * Optionally wrap the given str to a max width of width characters per line
 * while indenting with indent spaces. Do not wrap if insufficient width or
 * string is manually formatted.
 *
 * @param {String} str
 * @param {Number} width
 * @param {Number} indent
 * @return {String}
 * @api private
 */
function optionalWrap(str, width, indent) {
  // Detect manually wrapped and indented strings by searching for line breaks
  // followed by multiple spaces/tabs.
  if (str.match(/[\n]\s+/)) return str;
  // Do not wrap to narrow columns (or can end up with a word per line).
  const minWidth = 40;
  if (width < minWidth) return str;

  return wrap(str, width, indent);
}

/**
 * Output help information if help flags specified
 *
 * @param {Command} cmd - command to output help for
 * @param {Array} options - array of options to search for -h or --help
 * @api private
 */

function outputHelpIfRequested(cmd, options) {
  options = options || [];

  for (var i = 0; i < options.length; i++) {
    if (options[i] === cmd._helpLongFlag || options[i] === cmd._helpShortFlag) {
      cmd.outputHelp();
      // (Do not have all displayed text available so only passing placeholder.)
      cmd._exit(0, 'commander.helpDisplayed', '(outputHelp)');
    }
  }
}

/**
 * Takes an argument and returns its human readable equivalent for help usage.
 *
 * @param {Object} arg
 * @return {String}
 * @api private
 */

function humanReadableArgName(arg) {
  var nameOutput = arg.name + (arg.variadic === true ? '...' : '');

  return arg.required
    ? '<' + nameOutput + '>'
    : '[' + nameOutput + ']';
}

// for versions before node v0.8 when there weren't `fs.existsSync`
function exists(file) {
  try {
    if (fs.statSync(file).isFile()) {
      return true;
    }
  } catch (e) {
    return false;
  }
}

/**
 * Scan arguments and increment port number for inspect calls (to avoid conflicts when spawning new command).
 *
 * @param {string[]} args - array of arguments from node.execArgv
 * @returns {string[]}
 * @api private
 */

function incrementNodeInspectorPort(args) {
  // Testing for these options:
  //  --inspect[=[host:]port]
  //  --inspect-brk[=[host:]port]
  //  --inspect-port=[host:]port
  return args.map((arg) => {
    var result = arg;
    if (arg.indexOf('--inspect') === 0) {
      var debugOption;
      var debugHost = '127.0.0.1';
      var debugPort = '9229';
      var match;
      if ((match = arg.match(/^(--inspect(-brk)?)$/)) !== null) {
        // e.g. --inspect
        debugOption = match[1];
      } else if ((match = arg.match(/^(--inspect(-brk|-port)?)=([^:]+)$/)) !== null) {
        debugOption = match[1];
        if (/^\d+$/.test(match[3])) {
          // e.g. --inspect=1234
          debugPort = match[3];
        } else {
          // e.g. --inspect=localhost
          debugHost = match[3];
        }
      } else if ((match = arg.match(/^(--inspect(-brk|-port)?)=([^:]+):(\d+)$/)) !== null) {
        // e.g. --inspect=localhost:1234
        debugOption = match[1];
        debugHost = match[3];
        debugPort = match[4];
      }

      if (debugOption && debugPort !== '0') {
        result = `${debugOption}=${debugHost}:${parseInt(debugPort) + 1}`;
      }
    }
    return result;
  });
}
