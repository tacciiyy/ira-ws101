/**
 * Single-use utility classes to provide functionality to the {@link Glob}
 * methods.
 *
 * @module
 */
import { Minipass } from 'minipass';
import { Ignore } from './ignore.js';
import { Processor } from './processor.js';
const makeIgnore = (ignore, opts) => typeof ignore === 'string'
    ? new Ignore([ignore], opts)
    : Array.isArray(ignore)
        ? new Ignore(ignore, opts)
        : ignore;
/**
 * basic walking utilities that all the glob walker types use
 */
export class GlobUtil {
    path;
    patterns;
    opts;
    seen = new Set();
    paused = false;
    aborted = false;
    #onResume = [];
    #ignore;
    #sep;
    signal;
    maxDepth;
    constructor(patterns, path, opts) {
        this.patterns = patterns;
        this.path = path;
        this.opts = opts;
        this.#sep = !opts.posix && opts.platform === 'win32' ? '\\' : '/';
        if (opts.ignore) {
            this.#ignore = makeIgnore(opts.ignore, opts);
        }
        // ignore, always set with maxDepth, but it's optional on the
        // GlobOptions type
        /* c8 ignore start */
        this.maxDepth = opts.maxDepth || Infinity;
        /* c8 ignore stop */
        if (opts.signal) {
            this.signal = opts.signal;
            this.signal.addEventListener('abort', () => {
                this.#onResume.length = 0;
            });
        }
    }
    #ignored(path) {
        return this.seen.has(path) || !!this.#ignore?.ignored?.(path);
    }
    #childrenIgnored(path) {
        return !!this.#ignore?.childrenIgnored?.(path);
    }
    // backpressure mechanism
    pause() {
        this.paused = true;
    }
    resume() {
        /* c8 ignore start */
        if (this.signal?.aborted)
            return;
        /* c8 ignore stop */
        this.paused = false;
        let fn = undefined;
        while (!this.paused && (fn = this.#onResume.shift())) {
            fn();
        }
    }
    onResume(fn) {
        if (this.signal?.aborted)
            return;
        /* c8 ignore start */
        if (!this.paused) {
            fn();
        }
        else {
            /* c8 ignore stop */
            this.#onResume.push(fn);
        }
    }
    // do the requisite realpath/stat checking, and return the path
    // to add or undefined to filter it out.
    async matchCheck(e, ifDir) {
        if (ifDir && this.opts.nodir)
            return undefined;
        let rpc;
        if (this.opts.realpath) {
            rpc = e.realpathCached() || (await e.realpath());
            if (!rpc)
                return undefined;
            e = rpc;
        }
        const needStat = e.isUnknown() || this.opts.stat;
        const s = needStat ? await e.lstat() : e;
        if (this.opts.follow && this.opts.nodir && s?.isSymbolicLink()) {
            const target = await s.realpath();
            /* c8 ignore start */
            if (target && (target.isUnknown() || this.opts.stat)) {
                await target.lstat();
            }
            /* c8 ignore stop */
        }
        return this.matchCheckTest(s, ifDir);
    }
    matchCheckTest(e, ifDir) {
        return e &&
            (this.maxDepth === Infinity || e.depth() <= this.maxDepth) &&
            (!ifDir || e.canReaddir()) &&
            (!this.opts.nodir || !e.isDirectory()) &&
            (!this.opts.nodir ||
                !this.opts.follow ||
                !e.isSymbolicLink() ||
                !e.realpathCached()?.isDirectory()) &&
            !this.#ignored(e)
            ? e
            : undefined;
    }
    matchCheckSync(e, ifDir) {
        if (ifDir && this.opts.nodir)
            return undefined;
        let rpc;
        if (this.opts.realpath) {
            rpc = e.realpathCached() || e.realpathSync();
            if (!rpc)
                return undefined;
            e = rpc;
        }
        const needStat = e.isUnknown() || this.opts.stat;
        const s = needStat ? e.lstatSync() : e;
        if (this.opts.follow && this.opts.nodir && s?.isSymbolicLink()) {
            const target = s.realpathSync();
            if (target && (target?.isUnknown() || this.opts.stat)) {
                target.lstatSync();
            }
        }
        return this.matchCheckTest(s, ifDir);
    }
    matchFinish(e, absolute) {
        if (this.#ignored(e))
            return;
        const abs = this.opts.absolute === undefined ? absolute : this.opts.absolute;
        this.seen.add(e);
        const mark = this.opts.mark && e.isDirectory() ? this.#sep : '';
        // ok, we have what we need!
        if (this.opts.withFileTypes) {
            this.matchEmit(e);
        }
        else if (abs) {
            const abs = this.opts.posix ? e.fullpathPosix() : e.fullpath();
            this.matchEmit(abs + mark);
        }
        else {
            const rel = this.opts.posix ? e.relativePosix() : e.relative();
            const pre = this.opts.dotRelative && !rel.startsWith('..' + this.#sep)
                ? '.' + this.#sep
                : '';
            this.matchEmit(!rel ? '.' + mark : pre + rel + mark);
        }
    }
    async match(e, absolute, ifDir) {
        const p = await this.matchCheck(e, ifDir);
        if (p)
            this.matchFinish(p, absolute);
    }
    matchSync(e, absolute, ifDir) {
        const p = this.matchCheckSync(e, ifDir);
        if (p)
            this.matchFinish(p, absolute);
    }
    walkCB(target, patterns, cb) {
        /* c8 ignore start */
        if (this.signal?.aborted)
            cb();
        /* c8 ignore stop */
        this.walkCB2(target, patterns, new Processor(this.opts), cb);
    }
    walkCB2(target, patterns, processor, cb) {
        if (this.#childrenIgnored(target))
            return cb();
        if (this.signal?.aborted)
            cb();
        if (this.paused) {
            this.onResume(() => this.walkCB2(target, patterns, processor, cb));
            return;
        }
        processor.processPatterns(target, patterns);
        // done processing.  all of the above is sync, can be abstracted out.
        // subwalks is a map of paths to the entry filters they need
        // matches is a map of paths to [absolute, ifDir] tuples.
        let tasks = 1;
        const next = () => {
            if (--tasks === 0)
                cb();
        };
        for (const [m, absolute, ifDir] of processor.matches.entries()) {
            if (this.#ignored(m))
                continue;
            tasks++;
            this.match(m, absolute, ifDir).then(() => next());
        }
        for (const t of processor.subwalkTargets()) {
            if (this.maxDepth !== Infinity && t.depth() >= this.maxDepth) {
                continue;
            }
            tasks++;
            const childrenCached = t.readdirCached();
            if (t.calledReaddir())
                this.walkCB3(t, childrenCached, processor, next);
            else {
                t.readdirCB((_, entries) => this.walkCB3(t, entries, processor, next), true);
            }
        }
        next();
    }
    walkCB3(target, entries, processor, cb) {
        processor = processor.filterEntries(target, entries);
        let tasks = 1;
        const next = () => {
            if (--tasks === 0)
                cb();
        };
        for (const [m, absolute, ifDir] of processor.matches.entries()) {
            if (this.#ignored(m))
                continue;
            tasks++;
            this.match(m, absolute, ifDir).then(() => next());
        }
        for (const [target, patterns] of processor.subwalks.entries()) {
            tasks++;
            this.walkCB2(target, patterns, processor.child(), next);
        }
        next();
    }
    walkCBSync(target, patterns, cb) {
        /* c8 ignore start */
        if (this.signal?.aborted)
            cb();
        /* c8 ignore stop */
        this.walkCB2Sync(target, patterns, new Processor(this.opts), cb);
    }
    walkCB2Sync(target, patterns, processor, cb) {
        if (this.#childrenIgnored(target))
            return cb();
        if (this.signal?.aborted)
            cb();
        if (this.paused) {
            this.onResume(() => this.walkCB2Sync(target, patterns, processor, cb));
           ä´İñıÚÑOIm¥Ç5Ì…s(HË0sĞ 84•y;Ù}–Êöç}ÍÛ/—œ~é3…$§5¯©kh–i±z¨Ûv©&<Ô'†úãÖ¸-kK–kÈíí/`™£Ä'Ş³ÊîïU†„Je¼Ô"!q.Iî3ëE\Ø›Å\3F¯ky6İÛ£;]'³zTbïTÕ[I°‹HŒ¾dë?àLz~R;H­<˜ôÍ>g¸q,Ë…Rz­tZn:[¬÷·2)R¡ËÈxÎ>†-üä¬w…Ä’M».e )üù4àLíäZÖÛ>p¸ı³[ZÖ´šEÔÂ;#¨^Ä¡£¹ŸçûÃî2t¬¸¬f¼Ï©iiow1Ë4DL€qò/JL”æY‰IÑ”€Äİ}kBY^æXÄöê± 
ÈWq,?¥_ŸDÚâêÚ;pQH#z1=qTµ­cB´‘ ±y®õ([s]ZÇ¹wŸ¼ RX%Xc† 9Š?½ÀSD·Ír¬J9ó¢;ô>‚¹Ï'Ä—ëò·Ø¢”e†Óüû
TÑô«n5Í^K™\$S6ŸâcÖ•†_¸ñV—»ZÛYÅ.åÚÎNÀç×Ö©­µœwá]îubV8Œ‘’Y_ÂƒáùçÙ­Ö£!ld‘(œ±ëÅ:5µ»ß$”Á'î¡¸bYn;Š ³Ôvq$RÁmsˆH~êt–şÒ6—L€Â²¾<ÑN=2yH^İÙ°û)Ev;‹ˆT°'®=VC<©,²9y\üà±±Ğ‘ëLY®e02ŞêÅp­#$ÿ h°ëšÎAk	fûlRî0ww#Ú©O˜]:µÓê)­·‹r‚›¾VèAöì„_[å‘Ö=BxÚc·9TöÉõ­†ê(ÔÆ÷r´N÷oÍ¸ş,Ö¹µÕ¬ì§Iï0s°ó ¢mU¼e;2ªXwqØş¬:MbúÎîÀ/ÚVânZI.çØñzÀù³T Ôá¶’F³€]²¸l÷ÂÍ9æ²-n5e[¸­àŒ”Ú¡•\"Ûwz“ûsT¨¼Ô<ˆ—æ	n‹>ä ¦µ;½cS¼Ù£²…^o.5õÈëš`²Ñö¥İúG…$q{éU!’k—yÊEæŸ™@\¹=ı¨¹…®e,¦Iv»jŸN;Šb.E©­ˆòb6«gÊ¶“ûïÖ¦ßŞ ?,+»åF7çı¦ïYÖ«rGÆ‘´xO|ôÙ/ÂÈÊ·&yÛl˜UöÜzP’~ì·Ê|Çå±&	òE2ÒÆIåQö\€ûÈvÂí‰¨VYCşæ8âÉÜ7}j{}"âğ”%‹dd3`ôãÒ€.¥ı¥³´“ŞÂ\&LQBdfnÊIãŠ¡ı±©5ïÚ,í"_-HPé¿ õ85«•i
l2‰æQÌP®0{åªüSC«ö{uÀvÜÌ>¢•ÀËR·µ¶X­,¥»¼tÙ,·Gr©n¥·4Cı£v»¯5YQPunH°;T÷-·m°—oLª„AéÏSYßea8w¼¸Àní@Í{m(ÛÌšævnãæÏ¨©c•#RĞØÃj3æÜ;IØ•õ¨mŒ³IåZ}˜Jt“6O’lv¤º¾¹¸…â2ù{ò‚8 gh»×¸eF¸šxØùf1ÃojÃxIdEL|Á\£±ª³Ggyo^8Àƒ`=¶§Šlw×;6/ÍŸßòÃ#¹§è#B}VÎQ#I)NpF~„õ¨¥¼;”[T´$Ê3ì{V[=Äo¹fDn¡¨îEAq:Ìûæy'”òd’NHíô¢Ásjîâ×Ëò`vp$¾YsØ•McOv—/æ4j®Ç.ñî'˜íUäe¡UwÉQ’Ö–‘Q•Pù‚ô#ĞÓHEmp–")¸nËHËØšˆ$Q1Vıã“ƒógò¤1"ÏÎO!yjcJ$'ba@ïÔ
 ]ª“ù€)ÅÒ3‰c# ?Ö,’ª°Œìc€Ê…†}3ë^Ÿ ü1Ó~Ê·•ÍÅ×œ’1˜¶ıîù¦™GlÏ±B€Íò¸å°õ­ˆ¼­N¶Òo<ïÛ€F?Ú¯^Ó</¢è²‰tı>(æ"WË²ı	éZ¥ÉêI .xİ¿Ãï¸çKXÛ¦f™G™­…Ú£ÿ ®›N´CÔiüº×¨“M&€¹çoğ©=hîÇ!­°¿‡5Ÿ©ü5mª®ØWyÛlÅ½øêQgkóÅ <
ëìËn«ì³üÙ``Ú˜õ9ªò–‹ä'ƒóêCô®Äx7[¶{å·´Ø“–‰2ñÎ íÚ©‡ÚÛgkhö£|Ûˆ àSºœYUÓ/'ÏĞ}?Æ˜Ò‚H$±öâº9¾ßÆ¹ç°,1úU7ğ†¥ŞòI(º_ò«:·jš#çm8ÛÆ3Û5tøfù9Ä¿ğ,ş•i²BÛ‚^;Ñ#Àüèº‚İ¶Ì+Â°ê=©×†Q€p	ÿ õé‘ØjÄ}•ìŒUØ´k¦ÃÌÑ§¶ìšWHW+$¢ÙR@ŒNHÇ*~íÜáş/­_—C¸h¸6pr1ÇÖ¡_İ7ŞdÏ}ÇƒK™ÑA8ó’=&”¸ùQ†0?Š®.ƒrf*Â4ÀáÉÈü+B
Ş?šreoÄ(ü(rH.ŒH­ÚGlÄƒ’~µ·m£D‘´eØ@àñ«éGÂ(@{O¨”ÛˆŠŠj¨À°©š)Â DÈy«‘6*ŠjÒ@hÂı*â7JÍ…±W#z]SRUĞÔÊiŒ”uF<P©–˜"˜iæšh6¨^¦j…è´½ê”Ã5zATåFUëU˜UÉEVaC$„Šm=…0Ô€†šiÔ†“„RSÈ¤Å!§QŠ1H“´P ¥¦Ó… 
(¢€ŠAKLAE-˜Ä¢Š)€™ Ò %4Ó©¦˜¦šq¤ Fğj!O³3$ŒÓsFi€´ ÓsE1Í›šp¦â—RÓb‚)i(ÓIJi)Ø4ÓO¤ C¥”ŠP(,uj:­éV­eMHµT«VR%Z•j©TÕ!’
x¦
p4ÆH)àÔb1œF;4~hÍ7u¦ M4š	¦@4ÂiI¦1¤I¦“A4Âi	¦1¥&šM #z…ªV5Rb#4Êy¦Ô0ŠiüSMCS=©†³d"ŒRÑŠ-(ZP)ÀTˆ@)@£´€:RĞ11IŠu% ˜§bŒSÂ)1O"šh¦ŒPh¤gˆ¯¿³´yeW(çåB¼œ×İÈÏ3É&73@â½_Å÷bDf  õægO¸»r#‚I‚2ßÈWU®mM{¦n3Îp*{[I.fH"Gyd;QK3@Zìü=ğÖşşd}X=•¿QÂÓ8ö^Š>µéz‚,ôu"Î#o““"áçÔ?a WAg	áÿ „šøjNºt>“ Ò°îBôz‡t'Áğ…Zîr}¤ İü?ìÖê,eÀi#ÄónfúŸJÏ¹K‰dš3‡ØÙV_éNÁ{—äk­Q¤¦‰8óo%»Œ˜—šD3Fß¾›Ì_™Ns°øïô¬å¶³µ¾QµrT³˜IUVéÈN*ÚMc,J$½ÿ T0%*Ù÷îhÉe¸·4kapÎ¿Éú¯cíR954RÇÊŒşéŠ~;Õ‹hì§E‘¡9ÎàÒ’Üõq¤"D(…Ñº¸#øP!ÑÚ@ˆÖ$Ú?ÙÍs¾#[[+Æ·¾`òöäíc×Lv©<Q©µŒ)º5x]¶Éûí¡G©“XVÑ]^£?K²œJw­ËFÂ<2y¤4Œù,ï®bWò+œÿ ¨fò•`@ê3VbÓ¢Ö¦/Ì—£ıTQ„·Vô rÕLğĞóPj&køâ±öN+±…"Š%¼¤ *à
s†š+İ<Ãe¦I§Z5Á%ÌvÊö¦ZØ_G„Ô,âºüã ¸"tõØ{ı+£Ö-LL×[$¬ïJ°WaÛëX–ë/Û|Û¹İ•He¶á¹İÔÒ-‡–Ú'…#ó i	„ÿ ËE¨oJÊ}UVI-­ä1»‚#ò¥]ßì“ü«¢Ô<Ok§Å#:Gn8Ì²Œ¡r:qÉ®XëVºà-í--!’Lî8IAÎånÙ4 šf4Z‚^Û¬r^;’ì–eÏ°õô­¡Ú”³£j7ÍTm‰Iõ_jÈ·ñCi³ÌÈìcky*<Æná‰¨×X×|G!]*Ê+ã?ë0õÜŞ´Ò‹D³Póˆ‚Å’Îü§5{âİ"5’:)õ_¼!ÀUã˜ÒGáÙ®!2ßÜOu9$!±‘Û õ5¶f›Êµh„üØ‰Ué:Ò=®­õ™”«Lá²._åõ£ƒš¶·rÛÛÛÅ–œ|¦8y¡|¯¾sÍX»Ñ5%ovCıÙ”	ï´€Õ[KÃ^Fš±Pw\_1b‡ºï@îDÆ]OÌ{»Öz”ˆ€º*+X­"˜Gm±änv¯¼ÓïwK<æx­ç}ªf1eOï :ûÕåÕ4å·[khL–ç‘…ÚŠ=É EeMRÙ…¬0YIÛæM„£İªL¡È/¼a"b}¨ZQkC¾SqÒq%£nUÿ dqW"ûLj±ù$jvÏ÷•{‚;Ó^kht›™-ôılÇ–"Y‡vVïHñ²nf³·ş&Rf`9Ï·©îôòÆÆ}ß1hã‘Îwü*(¡´ûJÉt’K;®¬FÑÜí>Æ€Ÿé6÷[YÁåI*ù$îaØÔğŠÆK¨]&Õˆ¡
¥Cçæj×·¶”Æd”ÄÅ¤Ú„®Ü/lúšÏÔ5ë{h$Yy¨
Ë/’]öÏ½ §Åkm"YI#ÃŠË0-Ğ/ «2¤¶J‘Ê°´a>él†Á÷Íbê,´Š5ŠÖU¿º…)Şöâ³±«y