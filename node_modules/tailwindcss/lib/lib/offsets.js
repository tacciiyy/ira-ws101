// @ts-check
"use strict";
Object.defineProperty(exports, "__esModule", {
    value: true
});
Object.defineProperty(exports, "Offsets", {
    enumerable: true,
    get: function() {
        return Offsets;
    }
});
const _bigSign = /*#__PURE__*/ _interop_require_default(require("../util/bigSign"));
const _remapbitfield = require("./remap-bitfield.js");
function _interop_require_default(obj) {
    return obj && obj.__esModule ? obj : {
        default: obj
    };
}
class Offsets {
    constructor(){
        /**
     * Offsets for the next rule in a given layer
     *
     * @type {Record<Layer, bigint>}
     */ this.offsets = {
            defaults: 0n,
            base: 0n,
            components: 0n,
            utilities: 0n,
            variants: 0n,
            user: 0n
        };
        /**
     * Positions for a given layer
     *
     * @type {Record<Layer, bigint>}
     */ this.layerPositions = {
            defaults: 0n,
            base: 1n,
            components: 2n,
            utilities: 3n,
            // There isn't technically a "user" layer, but we need to give it a position
            // Because it's used for ordering user-css from @apply
            user: 4n,
            variants: 5n
        };
        /**
     * The total number of functions currently registered across all variants (including arbitrary variants)
     *
     * @type {bigint}
     */ this.reservedVariantBits = 0n;
        /**
     * Positions for a given variant
     *
     * @type {Map<string, bigint>}
     */ this.variantOffsets = new Map();
    }
    /**
   * @param {Layer} layer
   * @returns {RuleOffset}
   */ create(layer) {
        return {
            layer,
            parentLayer: layer,
            arbitrary: 0n,
            variants: 0n,
            parallelIndex: 0n,
            index: this.offsets[layer]++,
            propertyOffset: 0n,
            property: "",
            options: []
        };
    }
    /**
   * @param {string} name
   * @returns {RuleOffset}
   */ arbitraryProperty(name) {
        return {
            ...this.create("utilities"),
            arbitrary: 1n,
            property: name
        };
    }
    /**
   * Get the offset for a variant
   *
   * @param {string} variant
   * @param {number} index
   * @returns {RuleOffset}
   */ forVariant(variant, index = 0) {
        let offset = this.variantOffsets.get(variant);
        if (offset === undefined) {
            throw new Error(`Cannot find offset for unknown variant ${variant}`);
        }
        return {
            ...this.create("variants"),
            variants: offset << BigInt(index)
        };
    }
    /**
   * @param {RuleOffset} rule
   * @param {RuleOffset} variant
   * @param {VariantOption} options
   * @returns {RuleOffset}
   */ applyVariantOffset(rule, variant, options) {
        options.variant = variant.variants;
        return {
            ...rule,
            layer: "variants",
            parentLayer: rule.layer === "variants" ? rule.parentLayer : rule.layer,
            variants: rule.variants | variant.variants,
            options: options.sort ? [].concat(options, rule.options) : rule.options,
            // TODO: Technically this is wrong. We should be handling parallel index on a per variant basis.
            // We'll take the max of all the parallel indexes for now.
            // @ts-ignore
            parallelIndex: max([
                rule.parallelIndex,
                variant.parallelIndex
            ])
        };
    }
    /**
   * @param {RuleOffset} offset
   * @param {number} parallelIndex
   * @returns {RuleOffset}
   */ applyParallelOffset(offset, parallelIndex) {
        return {
            ...offset,
            parallelIndex: BigInt(parallelIndex)
        };
    }
    /**
   * Each variant gets 1 bit per function / rule registered.
   * This is because multiple variants can be applied to a single rule and we need to know which ones are present and which ones are not.
   * Additionally, every unique group of variants is grouped together in the stylesheet.
   *
   * This grouping is order-independent. For instance, we do not differentiate between `hover:focus` and `focus:hover`.
   *
   * @param {string[]} variants
   * @param {(name: string) => number} getLength
   */ recordVariants(variants, getLength) {
        for (let variant of variants){
            this.recordVariant(variant, getLength(variant));
        }
    }
    /**
   * The same as `recordVariants` but for a single arbitrary variant at runtime.
   * @param {string} variant
   * @param {number} fnCount
   *
   * @returns {RuleOffset} The highest offset for this variant
   */ recordVariant(variant, fnCount = 1) {
        this.variantOffsets.set(variant, 1n << this.reservedVariantBits);
        // Ensure space is reserved for each "function" in the parallel variant
        // by offsetting the next variant by the number of parallel variants
        // in the one we just added.
        // Single functions that return parallel variants are NOT handled separately here
        // They're offset by 1 (or the number of functions) as usual
        // And each rule returned is tracked separately since the functions are evaluated lazily.
        // @see `RuleOffset.parallelIndex`
        this.reservedVariantBits += BigInt(fnCount);
        return {
            ...this.create("variants"),
            variants: this.variantOffsets.get(variant)
        };
    }
    /**
   * @param {RuleOffset} a
   * @param {RuleOffset} b
   * @returns {bigint}
   */ compare(a, b) {
        // Sort layers together
        if (a.layer !== b.layer) {
            return this.layerPositions[a.layer] - this.layerPositions[b.layer];
        }
        // When sorting the `variants` layer, we need to sort based on the parent layer as well within
        // this variants layer.
        if (a.parentLayer !== b.parentLayer) {
            return this.layerPositions[a.parentLayer] - this.layerPositions[b.parentLayer];
        }
        // Sort based on the sorting function
        for (let aOptions of a.options){
            for (let bOptions of b.options){
                if (aOptions.id !== bOptions.id) continue;
                if (!aOptions.sort || !bOptions.sort) continue;
                var _max;
                let maxFnVariant = (_max = max([
                    aOptions.variant,
                    bOptions.variant
                ])) !== null && _max !== void 0 ? _max : 0n;
                // Create a mask of 0s from bits 1..N where N represents the mask of the Nth bit
                let mask = ~(maxFnVariant | maxFnVariant - 1n);
                let aVariantsAfterFn = a.variants & mask;
                let bVariantsAfterFn = b.variants & mask;
                // If the variants the same, we _can_ sort them
                if (aVariantsAfterFn !== bVariantsAfterFn) {
                    continue;
                }
                let result = aOptions.sort({
                    value: aOptions.value,
                    modifier: aOptions.modifier
                }, {
                    value: bOptions.value,
                    modifier: bOptions.modifier
                });
                if (result !== 0) return result;
            }
        }
        // Sort variants in the order they were registered
        if (a.variants !== b.variants) {
            return a.variants - b.variants;
        }
        // Make sure each rule returned by a parallel variant is sorted in ascending order
        if (a.parallelIndex !== b.parallelIndex) {
            return a.parallelIndex - b.parallelIndex;
        }
        // Always sort arbitrary properties after other utilities
        if (a.arbitrary !== b.arbitrary) {
            return a.arbitrary - b.arbitrary;
        }
        // Always sort arbitrary properties alphabetically
        if (a.propertyOffset !== b.propertyOffset) {
            return a.propertyOffset - b.propertyOffset;
        }
        // Sort utilities, components, etcâ€¦ in the order they were registered
        return a.index - b.index;
    }
    /**
   * Arbitrary variants are recorded in the order they're encountered.
   * This means that the order is not stable bet>2+|˜yœ@î¼jAÊmû­ˆ&w)0éVtJ ¿”Ÿ£w ¢ñÏDi’å¬ú!y/Nª‰?1·'Jßñ×…ÒŒ	m
Âºß‚¥*4‰½­Lz«—«$«DŞi6û%ºÊôrûXqiüXzB+¬Jt¶I•öYRUê”`6Rlw~E.ºĞ‘pßó¿ànŸô™„t†¹ªå%åGU˜™G‡ÇbDYƒC·&D#nÊ‚!à“Á-ErrÊFpì³ìæuäêÇ«Ì›kEÌ/S.ÊHÕTì¤Ü¢ô¸6Œ75*ÔÖã³d“y80$Y†m¾<²¢•8TÓ2`ç”íØöwø®Ì&X.›gÎÌ•--¶¦bÿv2VGÈf¦ğ÷—›Ò\YI¼şşrşÂã—_j¢íô(^ÁW·‚Wş7õàÎò {_êŞµåÔÚ³Œ÷/(R²\tãâ
4ÆL ÊÇUŠÁE¬˜*OÊ„ò–üËä+´HÄÓÏ,Yeù:‘¾}Û\Õ¢°w÷S²æÉ€:ø«påÏÛ¾é½îj®45ç$%%œYsŸu§ú­ñ{áLÒ‚öÒºæ¥yï½û%š	ßó†hÄÔ7G[JgH«Då+òr(ù…UYB›ğ$½‡ó.ÛÊ5™!5ïµıUjµUÛÏ­r>½¾$ n¤É€:‚lbÕî›ä”õAšÄ”$@òêÍ¸rt+ÛB'ï7:š§T+‘ÄÙé÷°×UÌ*&I½’ßde?Õ·}Njí¯é3<,œH°4íq ËŒ1$r;`Ù	@E€8îÄ~.ş»lŞWò9urŠœl¹lÉ“UmÚ'‘š£†ú™Õ¹DÍŞI_
øüõCÎB<ü ¤fò’’Ly¥w×Sv!ïu­Ja·Õ6ØMÎ[êÅYb´5¸{’˜Õš:_%ğE£Ä‹ÛÙï‰°Ú˜%i'`?”ğ² Êò{¨bßñµ¸ç¦Ú}%yÖ¸4°/'Ç¹•é(Û@¸×ó(&qÓDÅl1%¥s;Ø¹U1&ÃÊ»õqH=„?”œ<h¸‰½9¹$’·šôª©Eò‘Ÿ®ê?NOS*^¹ªÙyĞ*ö¾KÙ7õS7EXÔøY;÷‹4xÃ**t´@¤â…ÛË½j¯:¦²ƒÃc‡Ï¢jV \‹‡nég(Ã®A1ieâdwBz	Î§¶WJŒ»5œ‡:LtCİuá­32+YÆjjfê îşÊ³Ùê:Ï?ÜÑİ§‘hÜÛ­èµÖ7ÉVŒÄş¼([©ÈlÓˆ ½|‹ôÍfkˆ›Uy)Ù%d÷—~´¼Ëó¨tähàÜ›t+çyÛÔÂ#ç,#ä4v5°±IWn!lúı¢Ù£û?ä’º<J¥H\ã_[&r‹xº·ô´“Õ@ dGîmøşö{ğŠ›N™ßş|¶¨¶%
*]K'&:°n)ÿ|y$ZeÀ^£ÜC>÷f«õÃ+£ˆ|/×~Ş÷S%°ÔDåä¶€‡%2x’t²asø˜ƒŸëo`E´Z‡t7ıt$Á—®¯¡+2O1DßíHíˆ<Eöæ„üÏKp<C™yÙêä¿ÚÚ“øº‰x£pÆ)B:'B÷ï^ŒÌwëæÎñÒ“-}?µ¤`b|Ç¯ly{µÙÖI†¦ûF’6b]0èÒ!›çË Ø©•78¼Å›UzTõn[::‚Üi@‚Æş€¢¤‡qF@ãÍ\V]CfÛO÷Wõukrsó [/©Ñˆzé_©ø»óµO i;‡Klú}•Š²R£ø¬©¾ó‰FQİ½É½ËA>Mnš^æ²N@33Ùºş‹Mb}œ;ºÁNÏ®\vÃ\ë£y!n'·ÃĞÙºÅàäx'ÁÎr¦“¯0{`MÎÖ}sd­-âşÎa¥m?¦~··óÛppvl8d¡Z!ß¥öy(‘zùØ½V?V­ğÔÒJ…À†RálîùêE„ï?	&ŒiZ×Laùõ×…ç ’&mIæcß"Ã%ö_¦•‰³¹%2X¿fq-áGŞQè^¨Šø“ÒèŠ÷¸Ñ\ÀÄ“+ÅÕzûö“F³ Ài)H+<Q>‹íh75¶­#ªo)±1…";ŞDä€¥ Ì·=÷—%åÁ< NÓğv)Œ$y9 S@ßq¥F]|AàñĞoq"°áw1{7÷çWİkGÍò/{G'¯]aò×\°ß}®ÄÏÛöUØE`§ûĞhÅkõe2wºi/HıÜKŠÅş_DĞ Ü&¡t¹A9ËæIö£ÚàĞ[^%Ú?ºyr‹NòÒö^9²G	]õOé$ñåıñ™7íb¢=Ø%Ny÷a9yŸá£¯ó­Jú/»O²Ù«V'®iò ló|¦-”bTÏóH² 
Æ'_>¹ÒÑ6ŞÕüú¾tºŸ™bH·€].¶ö´:§‹F½no¢Q/c´=ƒÄ{ ¯¶~¶/Á5de`ZCƒè=,üò‘5À™¶«¡%cáUaZåQCGh_E0Åé\¥²	½æÅ¡Èe=¸Lº€•5r+TS*ğ	=Âe6Ù?ŒEêW¨ıÍ.Çc‰òl˜—ñuıèŠªKwG¬ãç¶:h:YU[X¦²ù»É{0$ëAú«İœdCªL²àö HrÈ«×è6¹Áñ.6˜V\1X3di³ã¡+i_¤œX‡Æ3ª¼ùĞ&KW¢<æ³št÷¦…½ Qy Ì¶="µCAuÛšÉsÙg¡¦t6C«4ğcBšyîŞCè+­/R&é ×Ş§ï4ùiÆâÑe¾ôƒöTb¡
[\®ızphÄ!t¶vd/ä¨Ô£6-zü8U¿	Cì[WDw83aAw¡óè‹TŞÈŸ”Ò7)—ÏdÒß@÷Îà”/dvó¹z±¦•M`´<„uéÏI@¸Wê·L“IØ¬ˆñòM°I&»ş¥n„zÑ ØÄy€øëSŠ+M|Ê\E1zT#Ø…Ë± aÔ‚Ø$:Ï.YaP«Áx9|‡ÁŸºÜn°¥%“ƒñ¥g'¦R³ÌYò\/9.ÎBG_ek¶—Iº›Ÿ#‹1Æ{7<¶jG­¯L-Ê¨øĞ0Â’TÃı”ÃkÒO³Çr>Uê^²øG-nS›€PŒÈ’ûâÙ~Ñ—PÊª)¶äúZÔ~Ç%®E¯•÷‰*ÿL%nñ„Ú‚I¦GEº
¦Ljt|Â´[Ëb{(yŠÔğOÈMÃİ7á•ß~F.äjw$SÖ /²ì*G£yT.º«í¸RU¨uşÓ‹v?ì°M†S®üR›÷ø‡b·f°Ö$‘@{õT[’©¡ˆ}-u»8Ç“@ó¼Æ¢™Şh·HxóµüóMàomÈ÷÷2£×G»BàÑ©ò×aÅJ‡`-“BŸ¢™rOş1e@ ¬uù†ÌÅÄF«½!qµ-kâ~{VcO¹Y©FNÔzÏ¸bÜFå~çğ;C×®jE<ÎnuFÆ"¨â‹n¾nÕ}8gPaŠ˜ù¾uv†RÔÏj¯¨Ä,Ô|ñq¼Ãºâ¸Ğ¥Eo‰ÃyM©·û6jˆÇR·/4ªšl[Ğ«¹(R$ä¸´«Š*ó]Á²—ĞyTH$	oãlü·Q¤må€¥iõ¥—W“pÔªÂ6$š_]’‘@ ,áÍÙ¡Ÿætâ6Ka¨ï•¨‰«;¼ô§
f“rdØübâád}CV‡÷ıİÜ´Oôì(élíL/œ$÷h¥â^mïïrc©@3BĞ·l¦øU—Éêæ§\õƒ/\6rWµ'°êƒæÁ Ù ¾Â—ˆ`k9-’ˆŠÇÖ"2(i´ö¿íàë³«Ú\®úÎèHòè÷{ËZ)î¸Fâ}`>Øf=åôl©Å¥©ä£Õ€¡ÕçB"ç¥kÄ2ûr_½` áXhOvF
ùÁE|ƒ&3ü±È¶%F’íVÄ±z¹IlÅcu~Bl2»te½¹»<•D'm»n§“t+¨½*O›1	0gÀ‡3¬—}Œõ£æŠÇâwãô\…µBäÁ‰ÖMAh:Ê-IY-ègwêıp¤¯xÚh%èT‡&´,o©^C¢©hüsƒ¯ÍsO·^r^]Æ úa!à}™§\ı?HàZ3Ö"«„L®†àÜr¯@²‡a:KQ(á
Xª+ÿYô*¼™ÜÙ3È¯^#MÍ˜ş¤æÇ÷xödÕ´(  è÷Ø%ª‹oƒ!o7U‚C„ô9œ~||W+9§{Õû%ªNÜŒÚƒ8>HÎÏ¬ZQŸ±$;„êŒº¯P§ƒĞ±Õ¾)MÙŠ°<¨Ó”ójğÛ}æ‡´Å†¿EêkìÈëÏ¤ÖEhUVeóK
`7ŞÜ9WˆP^ÊÑ~0Ãö
Ïêb0œµ	œbq’ÿ»Èá¸ÿ‡\JÑY¼BÆÙœ¬I•/BÎìï;ËÊ•{S¥Ã‰Ÿšıl^7Ñ¢r7É9±oµwkÛ$yíç™ÁÚ»GÏˆîˆÊt¿nÅâG™umE9É³IZc4÷`)Î,(^”†èM†®¿6ŠŸAôºzèò©íì#fÓEÉnO˜M¢Å†^ê˜fïø-ãê=[ÄBI»S<ğoBFFŒD*C¤¨³-’¥cğØ‚úÒdCV_§ŞĞÓ”ü×±Z#åiï"”e¡5Ö™)õ¶ße¡‰UÛÓiÑ¶à²û÷	¿ÍüûÒíÀÿƒE'{*"úÀNg~xõMØ=‹ û„ø|/+¶4u>µİ° ¶ÄÜ°KP²?õŞI]ëO8µ•ø¼ùtø·ÎMƒş^¿8ÊàwüƒW=wSÃ.‚äà†vbvÄÌ0tx·1¼6náK†mC)'õ³ÕÕÄ¥QÚ}½·‘ø<¿)LæDØï?,o&{$ÌhÊÛ–µ¢2õÀÔóç*¼D?¶ Ñ_:á.Äí+«Æ1›¬šê‹Àà¤¹
{’÷Fÿ¦\~“yÁBpîVÊäŸF“¶wkú>Èö#abæ-m[®Ôd'0™aÆ$‰¥éLuáPkAá/	ÊAqººÜ¸MĞT—ò6îÖqN.Â£‰£Ôc˜!ëûúT–·ê†Â)ŞNt ½Ì#@ÿŒLäìP¡UºX;PJHó[ ‹èuRüMîÛågÜ]¶’ü‰Ã™#LB¢êø|=Ì,,€€FowZñ!?k9>gÓÆáÿèU?Ğ·vuÒ>ó›d|Nê5*@ªYÌì;qzŞkÌ§V‡wgJ²'Ì@L›x+½¶ü@üÆ¡	êKªVs²ãØ–ìºÁ\–Ù–‡ìL;ŒH4°âYò)unn'“‰]şlZ¥¨Í·uaÕ„×ôšáÀÙì¹…ãë¾=ıKÅCÛº=Zú÷¢Áë‹Š¸äv)†t?¾BP0úe½ªpŞd	q/Ó&Yık ½w>ğ•~×§Êë½‰.z§ğÉ,¡éJ¸ËÄäxšÂÄSÔ@ïÑ©ÓŸ£ø¤/SÇ[$?ÄøCßÆºjiİÇ*ì£ß"Ô®“İœ™ü(-–ómüæÂ¹UäZØ³º8áÃÂxyG[aĞk<eÉj‘ÆD03¤¼E%j¥·ÂöÅ_‚¯mbªêß§ş4wƒ‚H_
ößGÌˆ„ø³-s£õºD·@1<~¬Hû.ÉxtıÀ0ÓåI]H}5ûTÄ¬§@0ôÆ»Íÿ›æ¸bª£D%=iŞêıƒTDƒÿboÃ„äÜÆû³ŞH2¾je›µ…Ó=’_¨«üÎ|l
à5ÿÃÊûSîèEæÖ½,¶Š»¨